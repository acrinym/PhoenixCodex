
>> ======================================== FILE: D:\github\phoenixcodex\CodexEngine\AmandaMapCore\Models.cs ========================================
>> 
namespace CodexEngine.AmandaMapCore.Models
{
    /// <summary>
    /// Represents the base class for any numbered entry found in the AmandaMap or related logs.
    /// This structure will be populated by the new intelligent parser.
    /// </summary>
    public abstract class NumberedMapEntry
    {
        /// <summary>
        /// The primary sorting key for these entries (e.g., 54 from "Threshold 54").
        /// </summary>
        public int Number { get; set; }

        /// <summary>
        /// The type of the entry, used for grouping in the UI (e.g., "Threshold", "WhisperedFlame").
        /// </summary>
        public string EntryType { get; protected set; } = "Generic";

        /// <summary>
        /// The full title of the entry.
        /// </summary>
        public required string Title { get; set; }

        /// <summary>
        /// The date associated with the entry, used for the Timeline view.
        /// </summary>
        public DateTime Date { get; set; }

        /// <summary>
        /// The full, raw text block that this entry was parsed from.
        /// </summary>
        public required string RawContent { get; set; }
    }

    // Concrete classes for each type of entry.
    // They can have more specific properties added later if needed.

    public class ThresholdEntry : NumberedMapEntry 
    {
        public ThresholdEntry() { EntryType = "Threshold"; }
    }
    public class WhisperedFlameEntry : NumberedMapEntry 
    {
        public WhisperedFlameEntry() { EntryType = "WhisperedFlame"; }
    }
    public class FieldPulseEntry : NumberedMapEntry 
    {
        public FieldPulseEntry() { EntryType = "FieldPulse"; }
    }

    public class SymbolicMomentEntry : NumberedMapEntry
    {
        public SymbolicMomentEntry() { EntryType = "SymbolicMoment"; }
    }

    public class ServitorLogEntry : NumberedMapEntry
    {
        public ServitorLogEntry() { EntryType = "Servitor"; }
    }

    // The original, simpler models can remain for now if they are used elsewhere,
    // but the new workflow will use the NumberedMapEntry classes above.
    public class AmandaMapEntry
    {
        public required string ID { get; set; }
        public required string Title { get; set; }
        public DateTime DateTime { get; set; }
        public string[] Tags { get; set; } = Array.Empty<string>();
        public required string Content { get; set; }
        public required string SourceFile { get; set; }
    }

    public class Threshold : AmandaMapEntry { }
    public class FlameVow : AmandaMapEntry { }
    public class FieldPulse : AmandaMapEntry { }
}

>> ======================================== FILE: D:\github\phoenixcodex\CodexEngine\ChatGPTLogManager\Models.cs ========================================
>> 
namespace CodexEngine.ChatGPTLogManager.Models
{
    public class ChatMessage
    {
        public required string Role { get; set; }
        public required string Content { get; set; }
        public DateTime Timestamp { get; set; }
    }

    public class GPTEntry
    {
        public List<ChatMessage> Messages { get; set; } = new();
        public required string SourceFile { get; set; }
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\CodexEngine\ExportEngine\Models\ExportModels.cs ========================================
>> 
using CodexEngine.ChatGPTLogManager.Models;
using System.Collections.Generic;

namespace CodexEngine.ExportEngine.Models;

/// <summary>
/// Represents a structured chat conversation ready for exporting.
/// This will be the common data format our renderers work with.
/// </summary>
public class ExportableChat
{
    public string Title { get; set; } = string.Empty;
    public List<ChatMessage> Messages { get; set; } = new();
    // We can add more metadata here later, like image data.
}

>> ======================================== FILE: D:\github\phoenixcodex\CodexEngine\ExportEngine\Renderers\IMarkdownRenderer.cs ========================================
>> 
using CodexEngine.ExportEngine.Models;

namespace CodexEngine.ExportEngine.Renderers;

/// <summary>
/// Defines a contract for rendering a chat to a Markdown string.
/// </summary>
public interface IMarkdownRenderer
{
    string Render(ExportableChat chat);
}

>> ======================================== FILE: D:\github\phoenixcodex\CodexEngine\ExportEngine\Renderers\MarkdownRenderer.cs ========================================
>> 
using CodexEngine.ExportEngine.Models;
using System;
using System.Text;

namespace CodexEngine.ExportEngine.Renderers;

/// <summary>
/// Implements the logic to render a chat conversation into a Markdown document.
/// </summary>
public class MarkdownRenderer : IMarkdownRenderer
{
    public string Render(ExportableChat chat)
    {
        var sb = new StringBuilder();

        sb.AppendLine($"# {chat.Title}");
        sb.AppendLine();
        sb.AppendLine("---");
        sb.AppendLine();

        foreach (var message in chat.Messages)
        {
            sb.AppendLine($"**{message.Role.ToUpper()}** ({message.Timestamp:yyyy-MM-dd HH:mm:ss})");
            sb.AppendLine();
            // Basic Markdown conversion for bold/italics could be added here later.
            sb.AppendLine(message.Content);
            sb.AppendLine();
            sb.AppendLine("---");
            sb.AppendLine();
        }

        return sb.ToString();
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\CodexEngine\ExportEngine\AmandaMapExporter.cs ========================================
>> 
namespace CodexEngine.ExportEngine
{
    public class AmandaMapExporter
    {
        public static void ExportToMarkdown(List<CodexEngine.AmandaMapCore.Models.AmandaMapEntry> entries, string path)
        {
            var sb = new System.Text.StringBuilder();
            foreach (var entry in entries)
            {
                sb.AppendLine($"## {entry.Title}\n**Date:** {entry.DateTime}\n**Tags:** {string.Join(", ", entry.Tags)}\n\n{entry.Content}\n\n---\n");
            }
            System.IO.File.WriteAllText(path, sb.ToString());
        }
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\CodexEngine\GrimoireCore\Models.cs ========================================
>> 
namespace CodexEngine.GrimoireCore.Models
{
    public class Ritual
    {
        public required string ID { get; set; }
        public required string Title { get; set; }
        public DateTime DateTime { get; set; }
        public string[] Tags { get; set; } = Array.Empty<string>();
        public string[] Steps { get; set; } = Array.Empty<string>();
        public string[] Ingredients { get; set; } = Array.Empty<string>();
        public required string Content { get; set; }
        
        // This property was missing
        public string? Purpose { get; set; }
        
        // This property was added correctly in the last step
        public string? Outcome { get; set; }
    }

    public class Ingredient
    {
        public required string Name { get; set; }
        public required string Category { get; set; }
        public string[] Uses { get; set; } = Array.Empty<string>();
        public string? Notes { get; set; }
    }

    public class Servitor
    {
        public required string Name { get; set; }
        public required string Purpose { get; set; }
        public required string VisualDescription { get; set; }
        public DateTime AnchorDate { get; set; }
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\CodexEngine\obj\Debug\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs ========================================
>> 
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

>> ======================================== FILE: D:\github\phoenixcodex\CodexEngine\obj\Debug\net8.0\CodexEngine.AssemblyInfo.cs ========================================
>> 
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("CodexEngine")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+a0658ab404719c53b76380018f4b56eca12004af")]
[assembly: System.Reflection.AssemblyProductAttribute("CodexEngine")]
[assembly: System.Reflection.AssemblyTitleAttribute("CodexEngine")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


>> ======================================== FILE: D:\github\phoenixcodex\CodexEngine\obj\Debug\net8.0\CodexEngine.GlobalUsings.g.cs ========================================
>> 
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

>> ======================================== FILE: D:\github\phoenixcodex\CodexEngine\Parsing\AmandamapJsonParser.cs ========================================
>> 
using System;
using System.Collections.Generic;
using System.Text.Json;
using CodexEngine.Parsing.Models;

namespace CodexEngine.Parsing
{
    public class AmandamapJsonParser
    {
        public List<BaseMapEntry> Parse(string jsonContent)
        {
            using var doc = JsonDocument.Parse(jsonContent);
            var entries = new List<BaseMapEntry>();
            foreach (var element in doc.RootElement.EnumerateArray())
            {
                if (!element.TryGetProperty("EntryType", out var typeProp))
                    continue;
                var type = typeProp.GetString();
                BaseMapEntry? entry = type switch
                {
                    "AmandaMap Entry" => ParseAmandaMapEntry(element),
                    "Threshold" => ParseThreshold(element),
                    "Whispered Flame" => ParseWhisperedFlame(element),
                    "Flame Vow" => ParseFlameVow(element),
                    "Phoenix Codex" => ParsePhoenixCodex(element),
                    _ => null
                };
                if (entry != null)
                    entries.Add(entry);
            }
            return entries;
        }

        private static string? Prop(JsonElement el, string name)
        {
            return el.TryGetProperty(name, out var prop) ? prop.GetString() : null;
        }

        private static AmandaMapEntry ParseAmandaMapEntry(JsonElement el)
        {
            return new AmandaMapEntry
            {
                Title = Prop(el, "Title") ?? string.Empty,
                Date = Prop(el, "Date") ?? string.Empty,
                Type = Prop(el, "Type") ?? string.Empty,
                Description = Prop(el, "Description") ?? string.Empty,
                Status = Prop(el, "Status") ?? string.Empty
            };
        }

        private static Threshold ParseThreshold(JsonElement el)
        {
            var coreThemes = new List<string>();
            if (el.TryGetProperty("CoreThemes", out var ct) && ct.ValueKind == JsonValueKind.Array)
            {
                foreach (var item in ct.EnumerateArray())
                {
                    var val = item.GetString();
                    if (val != null)
                        coreThemes.Add(val);
                }
            }
            return new Threshold
            {
                Title = Prop(el, "Title") ?? string.Empty,
                Date = Prop(el, "Date") ?? string.Empty,
                Description = Prop(el, "Description") ?? string.Empty,
                CoreThemes = coreThemes,
                FieldStatus = Prop(el, "FieldStatus") ?? string.Empty,
                MapClassification = Prop(el, "MapClassification") ?? string.Empty
            };
        }

        private static WhisperedFlame ParseWhisperedFlame(JsonElement el)
        {
            return new WhisperedFlame
            {
                Title = Prop(el, "Title") ?? string.Empty,
                Date = Prop(el, "Date") ?? string.Empty,
                SpokenPhrase = Prop(el, "SpokenPhrase") ?? string.Empty,
                Context = Prop(el, "Context") ?? string.Empty,
                Result = Prop(el, "Result") ?? string.Empty,
                MapClassification = Prop(el, "MapClassification") ?? string.Empty
            };
        }

        private static FlameVow ParseFlameVow(JsonElement el)
        {
            return new FlameVow
            {
                Title = Prop(el, "Title") ?? string.Empty,
                Date = Prop(el, "Date") ?? string.Empty,
                Invocation = Prop(el, "Invocation") ?? string.Empty,
                Description = Prop(el, "Description") ?? string.Empty,
                LinkedThreshold = Prop(el, "LinkedThreshold") ?? string.Empty,
                Classification = Prop(el, "Classification") ?? string.Empty,
                Status = Prop(el, "Status") ?? string.Empty
            };
        }

        private static PhoenixCodex ParsePhoenixCodex(JsonElement el)
        {
            return new PhoenixCodex
            {
                Title = Prop(el, "Title") ?? string.Empty,
                Date = Prop(el, "Date") ?? string.Empty,
                Context = Prop(el, "Context") ?? string.Empty,
                Purpose = Prop(el, "Purpose") ?? string.Empty,
                CodexPlacement = Prop(el, "CodexPlacement") ?? string.Empty,
                Status = Prop(el, "Status") ?? string.Empty
            };
        }
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\CodexEngine\Parsing\AmandamapParser.cs ========================================
>> 
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using CodexEngine.Parsing.Models;

namespace CodexEngine.Parsing
{
    public class AmandamapParser
    {
        public List<BaseMapEntry> Parse(string markdownContent)
        {
            var entries = new List<BaseMapEntry>();

            var blocks = Regex.Split(markdownContent, @"(?=üî±|üî•|üß±|üïØÔ∏è|üìú|ü™∂)");

            foreach (var block in blocks.Where(b => !string.IsNullOrWhiteSpace(b)))
            {
                var trimmed = block.Trim();
                BaseMapEntry? entry = null;

                if (trimmed.StartsWith("üî±")) entry = ParseAmandaMapEntry(trimmed);
                else if (trimmed.StartsWith("üî•") || trimmed.StartsWith("üß±")) entry = ParseThreshold(trimmed);
                else if (trimmed.StartsWith("üïØÔ∏è")) entry = ParseWhisperedFlame(trimmed);
                else if (trimmed.StartsWith("üìú")) entry = ParseFlameVow(trimmed);
                else if (trimmed.StartsWith("ü™∂")) entry = ParsePhoenixCodex(trimmed);

                if (entry != null) entries.Add(entry);
            }

            return entries;
        }

        private string? GetValue(string text, string key)
        {
            var match = Regex.Match(text, @$"{key}:\s*(.*)", RegexOptions.IgnoreCase);
            return match.Success ? match.Groups[1].Value.Trim() : null;
        }

        private string? GetMultiLineValue(string text, string key)
        {
            var match = Regex.Match(text, @$"{key}:\s*\n\n(.*?)(?=\n[^\s\n]|\Z)", RegexOptions.Singleline | RegexOptions.IgnoreCase);
            return match.Success ? match.Groups[1].Value.Trim() : GetValue(text, key);
        }

        private AmandaMapEntry ParseAmandaMapEntry(string block)
        {
            return new AmandaMapEntry
            {
                Title = GetValue(block, "Title"),
                Date = GetValue(block, "Date"),
                Type = GetValue(block, "Type"),
                Description = GetMultiLineValue(block, "Description"),
                Status = GetValue(block, "Status")
            };
        }

        private Threshold ParseThreshold(string block)
        {
            var titleMatch = Regex.Match(block, @"(üß±|üî•)\s*(.*)");
            var threshold = new Threshold
            {
                Title = titleMatch.Success ? titleMatch.Groups[2].Value.Trim() : "Untitled Threshold",
                Date = GetValue(block, "Date Activated") ?? GetValue(block, "Date"),
                Description = GetMultiLineValue(block, "Description"),
                CoreThemes = GetValue(block, "Core Themes")?.Split(',').Select(s => s.Trim()).ToList() ?? new List<string>(),
                FieldStatus = GetValue(block, "Field Status"),
                MapClassification = GetValue(block, "Map Classification")
            };
            return threshold;
        }

        private WhisperedFlame ParseWhisperedFlame(string block)
        {
            return new WhisperedFlame
            {
                Title = GetValue(block, "Title"),
                Date = GetValue(block, "Date Spoken") ?? GetValue(block, "Date"),
                SpokenPhrase = GetValue(block, "Spoken Phrase"),
                Context = GetMultiLineValue(block, "Context"),
                Result = GetValue(block, "Result"),
                MapClassification = GetValue(block, "Map Classification")
            };
        }

        private FlameVow ParseFlameVow(string block)
        {
            return new FlameVow
            {
                Title = GetValue(block, "Title"),
                Date = GetValue(block, "Date Declared") ?? GetValue(block, "Date"),
                Invocation = GetMultiLineValue(block, "Invocation"),
                Description = GetMultiLineValue(block, "Description"),
                LinkedThreshold = GetValue(block, "Linked Threshold"),
                Classification = GetValue(block, "Classification"),
                Status = GetValue(block, "Status")
            };
        }

        private PhoenixCodex ParsePhoenixCodex(string block)
        {
            return new PhoenixCodex
            {
                Title = GetValue(block, "Title"),
                Date = GetValue(block, "Date"),
                Context = GetMultiLineValue(block, "Context"),
                Purpose = GetValue(block, "Purpose"),
                CodexPlacement = GetValue(block, "Codex Placement"),
                Status = GetValue(block, "Status")
            };
        }
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\CodexEngine\Parsing\EntryParserService.cs ========================================
>> 
using System.Text.RegularExpressions;
using CodexEngine.GrimoireCore.Models;
using CodexEngine.AmandaMapCore.Models;
using System;
using System.Globalization;
using CodexEngine.Parsing;

namespace CodexEngine.Parsing
{
    /// <summary>
    /// Implements the logic to parse raw text into structured Ritual or NumberedMapEntry objects.
    /// </summary>
    public class EntryParserService : IEntryParserService
    {
        // Regex to find a numbered entry. It captures the type (Threshold, FieldPulse, etc.) and the number.
        private static readonly Regex NumberedEntryPattern = new(@"üî•|üî±|üîä|üì°|üïØÔ∏è|ü™û|üåÄ|üåô|ü™ß\s*(?<type>\w+)\s*(?<number>\d+):(?<title>.*)", RegexOptions.Compiled);

        public object? ParseEntry(string rawText)
        {
            if (string.IsNullOrWhiteSpace(rawText))
            {
                return null;
            }

            if (rawText.Contains("Ritual Name:") && rawText.Contains("Purpose:"))
            {
                return ParseRitual(rawText);
            }

            var numberedMatch = NumberedEntryPattern.Match(rawText);
            if (numberedMatch.Success)
            {
                return ParseNumberedEntry(rawText, numberedMatch);
            }
            
            return null;
        }

        private string GetSection(string text, string header, string? nextHeader = null)
        {
            var pattern = nextHeader == null
                ? $@"(?<={Regex.Escape(header)})(.*)"
                : $@"(?<={Regex.Escape(header)})(.*?)(?={Regex.Escape(nextHeader)})";

            var match = Regex.Match(text, pattern, RegexOptions.Singleline);
            return match.Success ? match.Value.Trim() : string.Empty;
        }

        private Ritual? ParseRitual(string text)
        {
            try
            {
                var name = GetSection(text, "Ritual Name:", "Purpose:");
                var purpose = GetSection(text, "Purpose:", "üî• Ritual Effect");
                var ingredientsText = GetSection(text, "‚ú® Ritual Ingredients:", "‚öõÔ∏è Steps:");
                var stepsText = GetSection(text, "‚öõÔ∏è Steps:", "üîπ Afterward:");
                var afterward = GetSection(text, "üîπ Afterward:", "Status:");
                
                var dateMatch = Regex.Match(text, @"Date:\s*(.*)");
                var date = dateMatch.Success ? DateTime.Parse(dateMatch.Groups[1].Value.Trim()) : DateTime.MinValue;

                return new Ritual
                {
                    ID = Guid.NewGuid().ToString(),
                    Title = name,
                    Content = text,
                    Purpose = purpose,
                    Ingredients = ingredientsText.Split('\n', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries),
                    Steps = stepsText.Split('\n', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries),
                    Outcome = afterward,
                    DateTime = date
                };
            }
            catch { return null; }
        }
        
        private NumberedMapEntry? ParseNumberedEntry(string text, Match initialMatch)
        {
            try
            {
                var type = initialMatch.Groups["type"].Value.Trim();
                var number = int.Parse(initialMatch.Groups["number"].Value);
                var title = initialMatch.Groups["title"].Value.Trim();

                var dateMatch = Regex.Match(text, @"Date:\s*(.*)");
                var date = dateMatch.Success ? DateTime.Parse(dateMatch.Groups[1].Value.Trim(), CultureInfo.InvariantCulture) : DateTime.MinValue;

                return type switch
                {
                    "Threshold" => new ThresholdEntry { Title = title, RawContent = text, Number = number, Date = date },
                    "WhisperedFlame" => new WhisperedFlameEntry { Title = title, RawContent = text, Number = number, Date = date },
                    "FieldPulse" => new FieldPulseEntry { Title = title, RawContent = text, Number = number, Date = date },
                    "SymbolicMoment" => new SymbolicMomentEntry { Title = title, RawContent = text, Number = number, Date = date },
                    "Servitor" => new ServitorLogEntry { Title = title, RawContent = text, Number = number, Date = date },
                    _ => new ThresholdEntry { Title = title, RawContent = text, Number = number, Date = date } 
                };
            }
            catch { return null; }
        }
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\CodexEngine\Parsing\IEntryParserService.cs ========================================
>> 
namespace CodexEngine.Parsing
{
    /// <summary>
    /// Defines a contract for a service that can parse raw text into structured data objects.
    /// </summary>
    public interface IEntryParserService
    {
        /// <summary>
        /// Attempts to parse a block of text into a known entry type.
        /// </summary>
        /// <param name="rawText">The raw text content to parse.</param>
        /// <returns>A structured object (e.g., Ritual, ThresholdEntry) if successful; otherwise, null.</returns>
        object? ParseEntry(string rawText);
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\CodexEngine\Parsing\JsonMarkdownConverter.cs ========================================
>> 
using System.Collections.Generic;
using CodexEngine.Parsing.Models;

namespace CodexEngine.Parsing
{
    public static class JsonMarkdownConverter
    {
        public static string JsonToMarkdown(string json)
        {
            var parser = new AmandamapJsonParser();
            List<BaseMapEntry> entries = parser.Parse(json);
            var exporter = new MarkdownExporter();
            return exporter.Export(entries);
        }

        public static string MarkdownToJson(string markdown)
        {
            var parser = new AmandamapParser();
            List<BaseMapEntry> entries = parser.Parse(markdown);
            var options = new System.Text.Json.JsonSerializerOptions { WriteIndented = true };
            return System.Text.Json.JsonSerializer.Serialize(entries, options);
        }
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\CodexEngine\Parsing\MapEntries.cs ========================================
>> 
using System;
using System.Collections.Generic;

namespace CodexEngine.Parsing.Models
{
    public abstract class BaseMapEntry
    {
        public string EntryType { get; protected set; } = string.Empty;
        public string? Title { get; set; }
        public string? Date { get; set; }
        public abstract string ToMarkdownSummary();
    }

    public class AmandaMapEntry : BaseMapEntry
    {
        public string? Type { get; set; }
        public string? Description { get; set; }
        public string? Status { get; set; }

        public AmandaMapEntry()
        {
            EntryType = "AmandaMap Entry";
        }

        public override string ToMarkdownSummary()
        {
            var desc = Description ?? string.Empty;
            var shortDesc = desc.Length > 100 ? desc.Substring(0, 100) + "..." : desc;
            return $"### AmandaMap Entry: {Title}\n" +
                   $"- **Date:** {Date}\n" +
                   $"- **Type:** {Type}\n" +
                   $"- **Status:** {Status}\n" +
                   $"- **Details:** {shortDesc}";
        }
    }

    public class Threshold : BaseMapEntry
    {
        public List<string> CoreThemes { get; set; } = new();
        public string? FieldStatus { get; set; }
        public string? MapClassification { get; set; }
        public string? Description { get; set; }

        public Threshold()
        {
            EntryType = "Threshold";
        }

        public override string ToMarkdownSummary()
        {
            var desc = Description ?? string.Empty;
            var shortDesc = desc.Length > 80 ? desc.Substring(0, 80) + "..." : desc;
            return $"### {Title}\n" +
                   $"- **Date Activated:** {Date}\n" +
                   $"- **Field Impact:** {shortDesc}\n" +
                   $"- **Status:** {FieldStatus}";
        }
    }

    public class WhisperedFlame : BaseMapEntry
    {
        public string? SpokenPhrase { get; set; }
        public string? Context { get; set; }
        public string? Result { get; set; }
        public string? MapClassification { get; set; }

        public WhisperedFlame()
        {
            EntryType = "Whispered Flame";
        }

        public override string ToMarkdownSummary()
        {
            return $"### {Title}\n" +
                   $"- **Date:** {Date}\n" +
                   $"- **Phrase Spoken:** \"{SpokenPhrase}\"\n" +
                   $"- **Effect:** {Result}";
        }
    }

    public class FlameVow : BaseMapEntry
    {
        public string? Invocation { get; set; }
        public string? Description { get; set; }
        public string? LinkedThreshold { get; set; }
        public string? Classification { get; set; }
        public string? Status { get; set; }

        public FlameVow()
        {
            EntryType = "Flame Vow";
        }

        public override string ToMarkdownSummary()
        {
            var desc = Description ?? string.Empty;
            var shortDesc = desc.Length > 60 ? desc.Substring(0, 60) + "..." : desc;
            return $"### {Title}\n" +
                   $"- **Date:** {Date}\n" +
                   $"- **Classification:** {Classification}\n" +
                   $"- **Details:** {shortDesc}";
        }
    }

    public class PhoenixCodex : BaseMapEntry
    {
        public string? Context { get; set; }
        public string? Purpose { get; set; }
        public string? CodexPlacement { get; set; }
        public string? Status { get; set; }

        public PhoenixCodex()
        {
            EntryType = "Phoenix Codex";
        }

        public override string ToMarkdownSummary()
        {
            return $"### Phoenix Codex: {Title}\n" +
                   $"- **Date:** {Date}\n" +
                   $"- **Purpose:** {Purpose}\n" +
                   $"- **Status:** {Status}";
        }
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\CodexEngine\Parsing\MarkdownExporter.cs ========================================
>> 
using System.Collections.Generic;
using System.Text;
using CodexEngine.Parsing.Models;

namespace CodexEngine.Parsing
{
    public class MarkdownExporter
    {
        public string Export(List<BaseMapEntry> entries)
        {
            var sb = new StringBuilder();
            foreach (var entry in entries)
            {
                sb.AppendLine(entry.ToMarkdownSummary());
                sb.AppendLine();
                sb.AppendLine("---");
            }
            return sb.ToString();
        }
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\CodexEngine\RitualForge\Models.cs ========================================
>> 
namespace CodexEngine.RitualForge.Models
{
    public class RitualObject
    {
        public required string Name { get; set; }
        public required string Type { get; set; }
        public double[] Position { get; set; } = Array.Empty<double>();
        public double[] Scale { get; set; } = Array.Empty<double>();
        public string[] Tags { get; set; } = Array.Empty<string>();
    }

    public class RitualScene
    {
        public List<RitualObject> Objects { get; set; } = new();
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\CodexEngine\CodexEngine.csproj ========================================
>> 
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="VersOne.Epub" Version="3.3.4" />
    <PackageReference Include="UglyToad.PdfPig" Version="1.7.0-custom-5" />
  </ItemGroup>
</Project>

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Converters\DocEntryConverter.cs ========================================
>> 
using System;
using System.Collections.Generic;
using System.Globalization;
using Avalonia.Data.Converters;
using GPTExporterIndexerAvalonia.ViewModels;

namespace GPTExporterIndexerAvalonia.Converters;

public class DocEntryConverter : IMultiValueConverter
{
    public object? Convert(IList<object?> values, Type targetType, object? parameter, CultureInfo culture)
    {
        if (values.Count >= 2 && values[0] is TagMapDocument doc && values[1] is TagMapEntry entry)
            return (doc, entry);
        return null;
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Helpers\AdvancedIndexer.cs ========================================
>> 
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Text.RegularExpressions;

namespace GPTExporterIndexerAvalonia.Helpers;

public class SearchResult
{
    public required string File { get; init; }
    public List<string> Snippets { get; init; } = new();
    public string? Category { get; init; }
    public string? Preview { get; init; }
}

public class SearchOptions
{
    public bool CaseSensitive { get; set; }
    public bool UseFuzzy { get; set; }
    public bool UseAnd { get; set; } = true;
    public int ContextLines { get; set; } = 1;
}

public static class AdvancedIndexer
{
    private static readonly Regex TokenPattern = new("[A-Za-z0-9]+", RegexOptions.Compiled);

    private class Index
    {
        public Dictionary<string, HashSet<string>> Tokens { get; set; } = new(StringComparer.OrdinalIgnoreCase);
        public Dictionary<string, FileDetail> Files { get; set; } = new(StringComparer.OrdinalIgnoreCase);
    }

    private class FileDetail
    {
        public string Filename { get; set; } = string.Empty;
        public long Modified { get; set; }
        public string? Category { get; set; }
        public string? Preview { get; set; }
    }

    private class TagMapEntry
    {
        public string? Document { get; set; }
        public string? Category { get; set; }
        public string? Preview { get; set; }
    }

    public static void BuildIndex(string folderPath, string indexPath)
    {
        var tokens = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);
        var files = new Dictionary<string, FileDetail>(StringComparer.OrdinalIgnoreCase);

        var tagLookup = new Dictionary<string, TagMapEntry>(StringComparer.OrdinalIgnoreCase);
        var tagPath = Path.Combine(folderPath, "tagmap.json");
        if (File.Exists(tagPath))
        {
            try
            {
                var json = File.ReadAllText(tagPath);
                var entries = JsonSerializer.Deserialize<TagMapEntry[]>(json);
                if (entries != null)
                {
                    foreach (var e in entries)
                    {
                        if (!string.IsNullOrWhiteSpace(e.Document) && !tagLookup.ContainsKey(e.Document!))
                            tagLookup[e.Document!] = e;
                    }
                }
            }
            catch { }
        }

        foreach (var file in Directory.EnumerateFiles(folderPath, "*", SearchOption.AllDirectories))
        {
            var ext = Path.GetExtension(file).ToLowerInvariant();
            if (ext != ".txt" && ext != ".json" && ext != ".md")
                continue;
            string text;
            try { text = File.ReadAllText(file); } catch { continue; }

            var relative = Path.GetRelativePath(folderPath, file);
            var detail = new FileDetail
            {
                Filename = Path.GetFileName(file),
                Modified = File.GetLastWriteTimeUtc(file).Ticks
            };
            if (tagLookup.TryGetValue(relative, out var info) || tagLookup.TryGetValue(detail.Filename, out info))
            {
                detail.Category = info.Category;
                detail.Preview = info.Preview;
            }
            files[relative] = detail;

            foreach (Match m in TokenPattern.Matches(text))
            {
                var token = m.Value.ToLowerInvariant();
                if (!tokens.TryGetValue(token, out var set))
                {
                    set = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                    tokens[token] = set;
                }
                set.Add(relative);
            }
        }
        var index = new Index { Tokens = tokens, Files = files };
        var options = new JsonSerializerOptions { WriteIndented = true };
        File.WriteAllText(indexPath, JsonSerializer.Serialize(index, options));
    }

    public static IEnumerable<SearchResult> Search(string indexPath, string phrase, SearchOptions? options = null)
    {
        options ??= new SearchOptions();

        if (!File.Exists(indexPath) || string.IsNullOrWhiteSpace(phrase))
            yield break;
        var index = JsonSerializer.Deserialize<Index>(File.ReadAllText(indexPath));
        if (index == null)
            yield break;
        var tokens = phrase.Split(' ', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
        HashSet<string>? result = null;
        foreach (var token in tokens)
        {
            var term = options.CaseSensitive ? token : token.ToLowerInvariant();
            var current = new HashSet<string>();
            if (index.Tokens.TryGetValue(term, out var set))
                current.UnionWith(set);

            if (options.UseFuzzy)
            {
                foreach (var key in index.Tokens.Keys)
                {
                    var cmp = options.CaseSensitive ? key : key.ToLowerInvariant();
                    if (cmp == term) continue;
                    if (LevenshteinDistance(term, cmp) <= 2)
                        current.UnionWith(index.Tokens[key]);
                }
            }

            result = result == null ? new HashSet<string>(current) :
                (options.UseAnd ? new HashSet<string>(result.Intersect(current)) : new HashSet<string>(result.Union(current)));
        }
        if (result == null)
            yield break;
        foreach (var rel in result)
        {
            var fullPath = Path.Combine(Path.GetDirectoryName(indexPath)!, rel);
            var snippets = ExtractSnippets(fullPath, phrase, options.ContextLines);
            index.Files.TryGetValue(rel, out var detail);
            yield return new SearchResult
            {
                File = rel,
                Snippets = snippets,
                Category = detail?.Category,
                Preview = detail?.Preview
            };
        }
    }

    private static List<string> ExtractSnippets(string filePath, string phrase, int context)
    {
        var snippets = new List<string>();
        string[] lines;
        try { lines = File.ReadAllLines(filePath); } catch { return snippets; }
        var lowerPhrase = phrase.ToLowerInvariant();
        for (int i = 0; i < lines.Length; i++)
        {
            if (lines[i].ToLowerInvariant().Contains(lowerPhrase))
            {
                var start = Math.Max(0, i - context);
                var end = Math.Min(lines.Length, i + context + 1);
                snippets.Add(string.Join("\n", lines[start..end]));
            }
        }
        return snippets;
    }

    private static int LevenshteinDistance(ReadOnlySpan<char> a, ReadOnlySpan<char> b)
    {
        var dp = new int[a.Length + 1, b.Length + 1];
        for (int i = 0; i <= a.Length; i++) dp[i, 0] = i;
        for (int j = 0; j <= b.Length; j++) dp[0, j] = j;
        for (int i = 1; i <= a.Length; i++)
        {
            for (int j = 1; j <= b.Length; j++)
            {
                int cost = a[i - 1] == b[j - 1] ? 0 : 1;
                dp[i, j] = Math.Min(Math.Min(dp[i - 1, j] + 1, dp[i, j - 1] + 1), dp[i - 1, j - 1] + cost);
            }
        }
        return dp[a.Length, b.Length];
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Helpers\SimpleIndexer.cs ========================================
>> 
using System.Collections.Generic;
using System.IO;
using System.Text.Json;
using System.Linq;
using System.Text.RegularExpressions;

namespace GPTExporterIndexerAvalonia.Helpers;

public static class SimpleIndexer
{
    private static readonly Regex TokenPattern = new("[A-Za-z0-9]+", RegexOptions.Compiled);

    private class Index
    {
        public Dictionary<string, HashSet<string>> Tokens { get; set; } = new(StringComparer.OrdinalIgnoreCase);
    }

    public static void BuildIndex(string folderPath, string indexPath)
    {
        var tokens = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);
        foreach (var file in Directory.EnumerateFiles(folderPath, "*", SearchOption.AllDirectories))
        {
            var ext = Path.GetExtension(file).ToLowerInvariant();
            if (ext != ".txt" && ext != ".json" && ext != ".md")
                continue;
            string text;
            try { text = File.ReadAllText(file); } catch { continue; }

            foreach (Match m in TokenPattern.Matches(text))
            {
                var token = m.Value.ToLowerInvariant();
                if (!tokens.TryGetValue(token, out var set))
                {
                    set = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                    tokens[token] = set;
                }
                set.Add(Path.GetRelativePath(folderPath, file));
            }
        }
        var index = new Index { Tokens = tokens };
        var options = new JsonSerializerOptions { WriteIndented = true };
        File.WriteAllText(indexPath, JsonSerializer.Serialize(index, options));
    }

    public static IEnumerable<string> Search(string indexPath, string phrase)
    {
        if (!File.Exists(indexPath) || string.IsNullOrWhiteSpace(phrase))
            yield break;
        var index = JsonSerializer.Deserialize<Index>(File.ReadAllText(indexPath));
        if (index == null)
            yield break;
        var tokens = phrase.Split(' ', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
        HashSet<string>? result = null;
        foreach (var token in tokens)
        {
            if (!index.Tokens.TryGetValue(token.ToLowerInvariant(), out var set))
                set = new HashSet<string>();
            result = result == null ? new HashSet<string>(set) : new HashSet<string>(result.Intersect(set));
        }
        if (result == null)
            yield break;
        foreach (var path in result)
            yield return path;
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\obj\Debug\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs ========================================
>> 
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\obj\Debug\net8.0\GPTExporterIndexerAvalonia.AssemblyInfo.cs ========================================
>> 
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("GPTExporterIndexerAvalonia")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+a0658ab404719c53b76380018f4b56eca12004af")]
[assembly: System.Reflection.AssemblyProductAttribute("GPTExporterIndexerAvalonia")]
[assembly: System.Reflection.AssemblyTitleAttribute("GPTExporterIndexerAvalonia")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\obj\Debug\net8.0\GPTExporterIndexerAvalonia.GlobalUsings.g.cs ========================================
>> 
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Reading\BookReader.cs ========================================
>> 
using System;
using System.Collections.ObjectModel;
using System.IO;
using Avalonia.Media.Imaging;
using Avalonia;
using Docnet.Core;
using Docnet.Core.Models;
using SkiaSharp;
using System.Runtime.InteropServices;

namespace GPTExporterIndexerAvalonia.Reading;

public class BookReader
{
    public ObservableCollection<Bitmap> Pages { get; } = new();

    public void Load(string path)
    {
        Pages.Clear();
        if (string.IsNullOrWhiteSpace(path) || !File.Exists(path))
            return;

        using var docReader = DocLib.Instance.GetDocReader(File.ReadAllBytes(path), new PageDimensions(1080, 1920));
        var pageCount = docReader.GetPageCount();
        for (var i = 0; i < pageCount; i++)
        {
            using var page = docReader.GetPageReader(i);
            var width = page.GetPageWidth();
            var height = page.GetPageHeight();
            var raw = page.GetImage();

            var info = new SKImageInfo(width, height, SKColorType.Bgra8888, SKAlphaType.Premul);
            var handle = GCHandle.Alloc(raw, GCHandleType.Pinned);
            try
            {
                using var bitmap = new SKBitmap();
                bitmap.InstallPixels(info, handle.AddrOfPinnedObject(), info.RowBytes);
                using var image = SKImage.FromBitmap(bitmap);
                using var data = image.Encode(SKEncodedImageFormat.Png, 100);
                using var ms = new MemoryStream(data.ToArray());
                Pages.Add(new Bitmap(ms));
            }
            finally
            {
                handle.Free();
            }
        }
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Reading\TagMapImporter.cs ========================================
>> 
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Microsoft.VisualBasic.FileIO;
using DocumentFormat.OpenXml.Packaging;
using DocumentFormat.OpenXml.Spreadsheet;
using GPTExporterIndexerAvalonia.ViewModels;
using System.Text.Json;

namespace GPTExporterIndexerAvalonia.Reading;

public static class TagMapImporter
{
    public static List<TagMapEntry> Load(string path)
    {
        var entries = new List<TagMapEntry>();
        if (string.IsNullOrWhiteSpace(path) || !File.Exists(path))
            return entries;

        var ext = Path.GetExtension(path).ToLowerInvariant();
        if (ext == ".json")
        {
            try
            {
                var json = File.ReadAllText(path);
                var arr = JsonSerializer.Deserialize<TagMapEntry[]>(json);
                if (arr != null)
                    entries.AddRange(arr);
            }
            catch { }
            return entries;
        }

        if (ext == ".xlsx" || ext == ".xlsm" || ext == ".xltx" || ext == ".xltm")
            LoadExcel(path, entries);
        else
            LoadCsv(path, entries);

        return entries;
    }

    private static void LoadCsv(string path, List<TagMapEntry> entries)
    {
        try
        {
            using var parser = new TextFieldParser(path);
            parser.SetDelimiters(",");
            parser.HasFieldsEnclosedInQuotes = true;
            if (parser.EndOfData)
                return;
            var headers = parser.ReadFields() ?? Array.Empty<string>();
            while (!parser.EndOfData)
            {
                var fields = parser.ReadFields() ?? Array.Empty<string>();
                var record = new Dictionary<string, string?>(StringComparer.OrdinalIgnoreCase);
                for (int i = 0; i < headers.Length && i < fields.Length; i++)
                    record[headers[i]] = fields[i];
                entries.Add(CreateEntry(record));
            }
        }
        catch { }
    }

    private static void LoadExcel(string path, List<TagMapEntry> entries)
    {
        try
        {
            using var doc = SpreadsheetDocument.Open(path, false);
            var workbookPart = doc.WorkbookPart;
            if (workbookPart == null)
                return;
            var sheet = workbookPart.Workbook.Sheets?.Elements<Sheet>().FirstOrDefault();
            if (sheet == null)
                return;
            var worksheetPart = (WorksheetPart)workbookPart.GetPartById(sheet.Id!);
            var sheetData = worksheetPart.Worksheet.GetFirstChild<SheetData>();
            if (sheetData == null)
                return;

            var rows = sheetData.Elements<Row>().ToList();
            if (rows.Count == 0)
                return;
            var shared = workbookPart.SharedStringTablePart?.SharedStringTable;

            var headers = rows[0].Elements<Cell>()
                .Select(c => GetCellValue(c, shared)?.Trim() ?? string.Empty)
                .ToList();

            foreach (var row in rows.Skip(1))
            {
                var cells = row.Elements<Cell>().ToList();
                var record = new Dictionary<string, string?>(StringComparer.OrdinalIgnoreCase);
                for (int i = 0; i < headers.Count; i++)
                {
                    var val = i < cells.Count ? GetCellValue(cells[i], shared) : null;
                    record[headers[i]] = val;
                }
                entries.Add(CreateEntry(record));
            }
        }
        catch { }
    }

    private static string? GetCellValue(Cell cell, SharedStringTable? shared)
    {
        if (cell == null)
            return null;
        var value = cell.CellValue?.InnerText;
        if (cell.DataType?.Value == CellValues.SharedString && int.TryParse(value, out var index))
            return shared?.ElementAtOrDefault(index)?.InnerText;
        return value;
    }

    private static TagMapEntry CreateEntry(Dictionary<string, string?> record)
    {
        var entry = new TagMapEntry
        {
            Document = record.TryGetValue("Document", out var doc) ? doc ?? string.Empty : string.Empty,
            Category = record.TryGetValue("Category", out var cat) ? cat ?? string.Empty : string.Empty,
            Preview = record.TryGetValue("Marker Preview", out var prev) ? prev : null
        };
        if (record.TryGetValue("Line #", out var lineStr) && int.TryParse(lineStr, out var line))
            entry.Line = line;
        return entry;
    }
}


>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Services\DebugLogger.cs ========================================
>> 
using System;
using System.IO;

namespace GPTExporterIndexerAvalonia.Services
{
    /// <summary>
    /// A simple static logger to write debug messages to a file.
    /// </summary>
    public static class DebugLogger
    {
        // The log file will be created in the application's base directory (e.g., the 'bin/Debug' folder).
        private static readonly string LogPath = Path.Combine(AppContext.BaseDirectory, "debuglog.txt");
        private static readonly object _lock = new object();

        /// <summary>
        /// Writes a message to the debug log file.
        /// </summary>
        /// <param name="message">The message to log.</param>
        public static void Log(string message)
        {
            try
            {
                lock (_lock)
                {
                    // Append text to the file, creating it if it doesn't exist.
                    File.AppendAllText(LogPath, $"{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff} - {message}{Environment.NewLine}");
                }
            }
            catch (Exception ex)
            {
                // To avoid the logger itself crashing the app, we can write to the debug console as a fallback.
                System.Diagnostics.Debug.WriteLine($"Failed to write to log file: {ex.Message}");
            }
        }
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Services\DialogService.cs ========================================
>> 
// FILE: GPTExporterIndexerAvalonia/Services/DialogService.cs
// REFACTORED
using Avalonia;
using Avalonia.Controls;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Platform.Storage;
using System.Linq;
using System.Threading.Tasks;

namespace GPTExporterIndexerAvalonia.Services;

/// <summary>
/// An implementation of IDialogService that uses Avalonia's storage provider.
/// It retrieves the main window from the application's lifetime manager,
/// allowing it to be used from anywhere without a direct window reference.
/// </summary>
public class DialogService : IDialogService
{
    private Window? GetMainWindow()
    {
        if (Application.Current?.ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
        {
            return desktop.MainWindow;
        }
        return null;
    }

    public async Task<string?> ShowOpenFolderDialogAsync(string title)
    {
        var mainWindow = GetMainWindow();
        if (mainWindow is null) return null;

        var result = await mainWindow.StorageProvider.OpenFolderPickerAsync(new FolderPickerOpenOptions
        {
            Title = title,
            AllowMultiple = false
        });

        return result.FirstOrDefault()?.Path.LocalPath;
    }

    // FIXED: Updated method to use the new FileFilter record.
    public async Task<string?> ShowOpenFileDialogAsync(string title, FileFilter filter)
    {
        var mainWindow = GetMainWindow();
        if (mainWindow is null) return null;

        var fileType = new FilePickerFileType(filter.Name)
        {
            Patterns = filter.Extensions.Select(ext => $"*.{ext}").ToList()
        };

        var result = await mainWindow.StorageProvider.OpenFilePickerAsync(new FilePickerOpenOptions
        {
            Title = title,
            AllowMultiple = false,
            FileTypeFilter = new[] { fileType }
        });

        return result.FirstOrDefault()?.Path.LocalPath;
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Services\ExportService.cs ========================================
>> 
using CodexEngine.ExportEngine.Models;
using CodexEngine.ExportEngine.Renderers;
using System;
using System.IO;
using System.Threading.Tasks;

namespace GPTExporterIndexerAvalonia.Services;

/// <summary>
/// Implements the export logic, delegating to specific renderers based on the requested format.
/// </summary>
public class ExportService : IExportService
{
    private readonly IMarkdownRenderer _markdownRenderer;
    // Other renderers (IHtmlRenderer, etc.) will be injected here later.

    public ExportService(IMarkdownRenderer markdownRenderer)
    {
        _markdownRenderer = markdownRenderer;
    }

    public async Task ExportAsync(ExportableChat chat, string outputFilePath, string format)
    {
        string content;

        switch (format.ToLowerInvariant())
        {
            case "markdown":
                content = _markdownRenderer.Render(chat);
                break;
            // Cases for "html", "rtf", etc., will be added here.
            default:
                throw new NotSupportedException($"The export format '{format}' is not supported.");
        }

        await File.WriteAllTextAsync(outputFilePath, content);
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Services\FileParsingService.cs ========================================
>> 
using CodexEngine.Parsing;
using CodexEngine.Parsing.Models;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.IO;
using System;
using System.Linq;
using CodexEngine.ExportEngine.Models;
using CodexEngine.ChatGPTLogManager.Models;

namespace GPTExporterIndexerAvalonia.Services;

/// <summary>
/// Implements <see cref="IFileParsingService"/> to handle file parsing and summary exporting.
/// </summary>
public class FileParsingService : IFileParsingService
{
    private readonly IExportService _exportService;

    // Inject the IExportService dependency.
    public FileParsingService(IExportService exportService)
    {
        _exportService = exportService;
        DebugLogger.Log("FileParsingService initialized.");
    }

    public Task<IEnumerable<BaseMapEntry>> ParseFileAsync(string filePath)
    {
        DebugLogger.Log($"FileParsingService: Parsing file '{filePath}'.");
        return Task.Run(() =>
        {
            try
            {
                if (string.IsNullOrWhiteSpace(filePath) || !File.Exists(filePath))
                    return Enumerable.Empty<BaseMapEntry>();

                var text = File.ReadAllText(filePath);
                List<BaseMapEntry> list;

                if (filePath.EndsWith(".json", StringComparison.OrdinalIgnoreCase))
                {
                    DebugLogger.Log("FileParsingService: Using JSON parser.");
                    list = new AmandamapJsonParser().Parse(text);
                }
                else
                {
                    DebugLogger.Log("FileParsingService: Using Markdown parser.");
                    list = new AmandamapParser().Parse(text);
                }
                DebugLogger.Log($"FileParsingService: Parsed {list.Count} entries.");
                return (IEnumerable<BaseMapEntry>)list;
            }
            catch (Exception ex)
            {
                DebugLogger.Log($"FileParsingService: Error parsing file '{filePath}'. Error: {ex.Message}");
                return Enumerable.Empty<BaseMapEntry>();
            }
        });
    }

    public async Task<string> ExportSummaryAsync(IEnumerable<BaseMapEntry> entries, string sourceFilePath)
    {
        DebugLogger.Log($"FileParsingService: Exporting summary for '{sourceFilePath}'.");
        try
        {
            var chatToExport = new ExportableChat
            {
                Title = Path.GetFileNameWithoutExtension(sourceFilePath),
                Messages = entries.Select(entry => new ChatMessage
                {
                    Role = "Summary",
                    Content = entry.ToMarkdownSummary(),
                    Timestamp = DateTime.Now
                }).ToList()
            };

            var outputFilePath = Path.ChangeExtension(sourceFilePath, ".summary.md");

            await _exportService.ExportAsync(chatToExport, outputFilePath, "Markdown");

            DebugLogger.Log($"FileParsingService: Summary exported to '{outputFilePath}'.");
            return outputFilePath;
        }
        catch (Exception ex)
        {
            DebugLogger.Log($"FileParsingService: Error exporting summary. Error: {ex.Message}");
            return string.Empty; // Return empty path on failure
        }
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Services\IDialogService.cs ========================================
>> 
// FILE: GPTExporterIndexerAvalonia/Services/IDialogService.cs
// REFACTORED
using System.Threading.Tasks;

namespace GPTExporterIndexerAvalonia.Services;

/// <summary>
/// A simple record to replace the obsolete FileDialogFilter class.
/// </summary>
public record FileFilter(string Name, string[] Extensions);

/// <summary>
/// Defines a contract for showing file/folder dialogs from a ViewModel
/// without a direct reference to the View.
/// </summary>
public interface IDialogService
{
    Task<string?> ShowOpenFolderDialogAsync(string title);

    // FIXED: Replaced obsolete FileDialogFilter with our new record type.
    Task<string?> ShowOpenFileDialogAsync(string title, FileFilter filter);
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Services\IExportService.cs ========================================
>> 
using CodexEngine.ExportEngine.Models;
using System.Threading.Tasks;

namespace GPTExporterIndexerAvalonia.Services;

/// <summary>
/// Defines a contract for a service that handles exporting chat data to various formats.
/// </summary>
public interface IExportService
{
    /// <summary>
    /// Exports a chat to a specified file path and format.
    /// </summary>
    /// <param name="chat">The chat data to export.</param>
    /// <param name="outputFilePath">The full path for the output file.</param>
    /// <param name="format">The desired format (e.g., "Markdown", "HTML").</param>
    Task ExportAsync(ExportableChat chat, string outputFilePath, string format);
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Services\IFileParsingService.cs ========================================
>> 
// FILE: GPTExporterIndexerAvalonia/Services/IFileParsingService.cs
// REFACTORED
using CodexEngine.Parsing.Models;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace GPTExporterIndexerAvalonia.Services;

/// <summary>
/// Defines the contract for a service that parses various file formats.
/// </summary>
public interface IFileParsingService
{
    /// <summary>
    /// Parses a file and extracts a list of map entries.
    /// </summary>
    /// <param name="filePath">The path to the file to parse.</param>
    /// <returns>A collection of parsed map entries.</returns>
    Task<IEnumerable<BaseMapEntry>> ParseFileAsync(string filePath);

    /// <summary>
    /// Exports a summary of parsed entries to a Markdown file.
    /// </summary>
    /// <param name="entries">The entries to export.</param>
    /// <param name="sourceFilePath">The original file path, used to determine the output path.</param>
    /// <returns>The path to the generated summary file.</returns>
    Task<string> ExportSummaryAsync(IEnumerable<BaseMapEntry> entries, string sourceFilePath);
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Services\IIndexingService.cs ========================================
>> 
using System.Threading.Tasks;

namespace GPTExporterIndexerAvalonia.Services;

/// <summary>
/// Defines the contract for a service that builds and manages the search index.
/// </summary>
public interface IIndexingService
{
    /// <summary>
    /// Builds a search index from the files in a specified folder.
    /// </summary>
    /// <param name="folderPath">The path to the folder to index.</param>
    /// <param name="isJsonIndex">True if indexing original JSON files, false for converted text files.</param>
    /// <returns>A task that represents the asynchronous build operation.</returns>
    Task BuildIndexAsync(string folderPath, bool isJsonIndex);
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Services\IndexingService.cs ========================================
>> 
using GPTExporterIndexerAvalonia.Helpers;
using System;
using System.IO;
using System.Threading.Tasks;

namespace GPTExporterIndexerAvalonia.Services;
/// <summary>
/// Service responsible for building the search index.
/// </summary>
public class IndexingService : IIndexingService
{
    public Task BuildIndexAsync(string folderPath, bool isJsonIndex)
    {
        // This is where the logic from MainWindowViewModel.BuildIndex will go.
        // We run it on a background thread to keep the UI responsive.
        return Task.Run(() =>
        {
            try
            {
                var indexPath = Path.Combine(folderPath, "index.json");
                DebugLogger.Log($"IndexingService: Starting index build for folder '{folderPath}'. Output: '{indexPath}'.");
                // For now, we'll just call the static method. This can be further
                // refactored into this class later.
                AdvancedIndexer.BuildIndex(folderPath, indexPath);
                DebugLogger.Log("IndexingService: Index build complete.");
            }
            catch (Exception ex)
            {
                DebugLogger.Log($"IndexingService: An error occurred during index build. Error: {ex.Message}");
            }
        });
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Services\ISearchService.cs ========================================
>> 
using GPTExporterIndexerAvalonia.Helpers;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace GPTExporterIndexerAvalonia.Services;
/// <summary>
/// Defines the contract for a service that searches the index.
/// </summary>
public interface ISearchService
{
    /// <summary>
    /// Searches the currently loaded index with the given query and options.
    /// </summary>
    /// <param name="indexPath">The full path to the index.json file.</param>
    /// <param name="query">The search phrase.</param>
    /// <param name="options">The options for the search (case sensitivity, etc.).</param>
    /// <returns>A collection of search results.</returns>
    Task<IEnumerable<SearchResult>> SearchAsync(string indexPath, string query, SearchOptions options);
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Services\SearchService.cs ========================================
>> 
using GPTExporterIndexerAvalonia.Helpers;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace GPTExporterIndexerAvalonia.Services;
/// <summary>
/// Implementation of <see cref="ISearchService"/> that uses the AdvancedIndexer.
/// </summary>
public class SearchService : ISearchService
{
    public Task<IEnumerable<SearchResult>> SearchAsync(string indexPath, string query, SearchOptions options)
    {
        DebugLogger.Log($"SearchService: Starting search for '{query}' in index '{indexPath}'.");
        return Task.Run(() =>
        {
            try
            {
                // The AdvancedIndexer.Search method is synchronous, so we run it on a background thread.
                var results = AdvancedIndexer.Search(indexPath, query, options);
                // We materialize the list here within the task to ensure enumeration happens off the UI thread.
                var resultList = results.ToList();
                DebugLogger.Log($"SearchService: Found {resultList.Count} results.");
                return (IEnumerable<SearchResult>)resultList;
            }
            catch (Exception ex)
            {
                DebugLogger.Log($"SearchService: An error occurred during search. Error: {ex.Message}");
                // Return an empty list in case of an error.
                return Enumerable.Empty<SearchResult>();
            }
        });
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Styles\MagicTheme.axaml ========================================
>> 
<Styles xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <Style Selector="Window">
        <Setter Property="Background">
            <Setter.Value>
                <LinearGradientBrush StartPoint="0,0" EndPoint="0,1">
                    <GradientStop Color="#1a0c24" Offset="0" />
                    <GradientStop Color="#0c023b" Offset="1" />
                </LinearGradientBrush>
            </Setter.Value>
        </Setter>
        <Setter Property="Foreground" Value="#e0e0e0" />
    </Style>

    <Style Selector="TabControl">
        <Setter Property="FontFamily" Value="Verdana, sans-serif" />
        <Setter Property="Background" Value="Transparent" />
    </Style>

    <Style Selector="TabItem">
        <Setter Property="Background" Value="#2a1c3d" />
        <Setter Property="Foreground" Value="#c0c0ff" />
        <Setter Property="Padding" Value="10,5" />
        <Setter Property="Margin" Value="2,0" />
    </Style>

    <Style Selector="TabItem:selected">
        <Setter Property="Background" Value="#4a2c6d" />
        <Setter Property="Foreground" Value="White" />
    </Style>

    <Style Selector="Button">
        <Setter Property="Background" Value="#592474" />
        <Setter Property="Foreground" Value="White" />
        <Setter Property="BorderBrush" Value="#8c4fb5" />
        <Setter Property="BorderThickness" Value="1" />
        <Setter Property="CornerRadius" Value="4" />
        <Setter Property="Padding" Value="10,5" />
        <Setter Property="HorizontalContentAlignment" Value="Center" />
    </Style>
</Styles>

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\ViewModels\Messages\AddNewAmandaMapEntryMessage.cs ========================================
>> 
using CommunityToolkit.Mvvm.Messaging.Messages;
using CodexEngine.AmandaMapCore.Models;

namespace GPTExporterIndexerAvalonia.ViewModels.Messages;

/// <summary>
/// A message that broadcasts a newly parsed NumberedMapEntry object to be added to the AmandaMap.
/// </summary>
public class AddNewAmandaMapEntryMessage : ValueChangedMessage<NumberedMapEntry>
{
    public AddNewAmandaMapEntryMessage(NumberedMapEntry value) : base(value)
    {
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\ViewModels\Messages\AddNewRitualMessage.cs ========================================
>> 
using CommunityToolkit.Mvvm.Messaging.Messages;
using CodexEngine.GrimoireCore.Models;

namespace GPTExporterIndexerAvalonia.ViewModels.Messages;

/// <summary>
/// A message that broadcasts a newly parsed Ritual object to be added to the Grimoire.
/// </summary>
public class AddNewRitualMessage : ValueChangedMessage<Ritual>
{
    public AddNewRitualMessage(Ritual value) : base(value)
    {
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\ViewModels\Messages\RitualsChangedMessage.cs ========================================
>> 
using CommunityToolkit.Mvvm.Messaging.Messages;

namespace GPTExporterIndexerAvalonia.ViewModels.Messages;

/// <summary>
/// A message that is sent whenever the collection of rituals is modified (added or removed).
/// Used to notify the TimelineViewModel that it needs to refresh its view.
/// </summary>
public class RitualsChangedMessage : ValueChangedMessage<bool>
{
    public RitualsChangedMessage() : base(true)
    {
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\ViewModels\Messages\SelectedMapEntryChangedMessage.cs ========================================
>> 
using CommunityToolkit.Mvvm.Messaging.Messages;
using CodexEngine.Parsing.Models;

namespace GPTExporterIndexerAvalonia.ViewModels.Messages;

/// <summary>
/// A message that is sent when a new map entry is selected in the UI.
/// Used to notify other ViewModels (like ChatLogViewModel) to update their state.
/// </summary>
public class SelectedMapEntryChangedMessage : ValueChangedMessage<BaseMapEntry?>
{
    public SelectedMapEntryChangedMessage(BaseMapEntry? value) : base(value)
    {
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\ViewModels\AmandaMapViewModel.cs ========================================
>> 
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.Mvvm.Messaging;
using CodexEngine.Parsing;
using CodexEngine.AmandaMapCore.Models;
using System.Collections.ObjectModel;
using System.IO;
using System;
using System.Linq;
using GPTExporterIndexerAvalonia.ViewModels.Messages;
using GPTExporterIndexerAvalonia.Services;
using System.Threading.Tasks;
using CodexEngine.Parsing.Models; // <-- THIS IS THE MISSING USING DIRECTIVE

namespace GPTExporterIndexerAvalonia.ViewModels;

// Implement the new IRecipient interface for adding entries
public partial class AmandaMapViewModel : ObservableObject, 
    IRecipient<SelectedMapEntryChangedMessage>, 
    IRecipient<AddNewAmandaMapEntryMessage>
{
    private readonly IMessenger _messenger;
    private readonly IDialogService _dialogService;

    [ObservableProperty]
    private string _filePath = string.Empty;

    // This new collection will hold our structured, numbered entries.
    public ObservableCollection<NumberedMapEntry> ProcessedEntries { get; } = new();

    // The old collection is no longer used by the new workflow but is kept for now.
    public ObservableCollection<BaseMapEntry> Entries { get; } = new();
    
    [ObservableProperty]
    private BaseMapEntry? _selectedEntry;

    public AmandaMapViewModel(IMessenger messenger, IDialogService dialogService)
    {
        _messenger = messenger;
        _dialogService = dialogService;
        _messenger.RegisterAll(this); // Registers this instance to receive all messages it implements a handler for
    }
    
    // This is the new method that handles receiving a parsed entry from the MainWindowViewModel
    public void Receive(AddNewAmandaMapEntryMessage message)
    {
        var newEntry = message.Value;

        // --- CONFLICT RESOLUTION ---
        // Check if an entry with this number already exists.
        if (ProcessedEntries.Any(e => e.Number == newEntry.Number))
        {
            // For now, we just log the conflict. A future step will be to show a dialog here.
            DebugLogger.Log($"CONFLICT: AmandaMap entry with number {newEntry.Number} already exists. New entry was not added.");
            return;
        }

        ProcessedEntries.Add(newEntry);

        // --- SORTING ---
        // Re-sort the entire collection by number to maintain order.
        var sortedEntries = new ObservableCollection<NumberedMapEntry>(ProcessedEntries.OrderBy(e => e.Number));
        ProcessedEntries.Clear();
        foreach (var entry in sortedEntries)
        {
            ProcessedEntries.Add(entry);
        }
    }
    
    // This message is from a legacy workflow and is no longer the primary way data is populated.
    public void Receive(SelectedMapEntryChangedMessage message)
    {
        // This is legacy from the old AmandaMap viewer, can be ignored for now.
    }

    // --- The old Load commands are now disabled to favor the new workflow ---

    // The CanExecute predicate will now return false, disabling the button.
    private bool CanLoad() => false; 

    [RelayCommand(CanExecute = nameof(CanLoad))]
    private async Task BrowseAndLoad()
    {
        // This logic is now handled by the new Search->Process workflow.
        await Task.CompletedTask; 
    }

    [RelayCommand(CanExecute = nameof(CanLoad))]
    private void Load()
    {
        // This logic is now handled by the new Search->Process workflow.
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\ViewModels\ChatLogViewModel.cs ========================================
>> 
// FILE: GPTExporterIndexerAvalonia/ViewModels/ChatLogViewModel.cs
// REFACTORED
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.Mvvm.Messaging; // New using
using CodexEngine.ChatGPTLogManager.Models;
using System.Collections.ObjectModel;
using System.IO;
using System.Text.Json;
using GPTExporterIndexerAvalonia.ViewModels.Messages; // New using
using System; // For StringComparison

namespace GPTExporterIndexerAvalonia.ViewModels;

// This ViewModel now implements IRecipient to receive messages
public partial class ChatLogViewModel : ObservableObject, IRecipient<SelectedMapEntryChangedMessage>
{
    public ObservableCollection<ChatMessage> Logs { get; } = new();
    public ObservableCollection<ChatMessage> FilteredLogs { get; } = new();

    // Constructor now takes the messenger and registers for messages
    public ChatLogViewModel(IMessenger messenger)
    {
        messenger.RegisterAll(this); // Registers this instance to receive messages
    }

    [ObservableProperty]
    private string? _filter;

    partial void OnFilterChanged(string? value)
    {
        FilterLogs();
    }

    // This method is called by the Messenger when a new SelectedMapEntryChangedMessage is sent
    public void Receive(SelectedMapEntryChangedMessage message)
    {
        // Update the filter based on the title of the newly selected map entry
        Filter = message.Value?.Title;
    }

    [RelayCommand]
    private void Load()
    {
        // Load logic remains the same
        var path = "chatlog.json";
        if (!File.Exists(path))
            return;
        var content = File.ReadAllText(path);
        var entry = JsonSerializer.Deserialize<GPTEntry>(content);
        if (entry?.Messages != null)
        {
            Logs.Clear();
            foreach (var m in entry.Messages)
                Logs.Add(m);
        }
        FilterLogs();
    }

    private void FilterLogs()
    {
        FilteredLogs.Clear();
        if (string.IsNullOrWhiteSpace(Filter))
        {
            foreach (var m in Logs)
                FilteredLogs.Add(m);
        }
        else
        {
            foreach (var m in Logs)
            {
                if (m.Content?.Contains(Filter, StringComparison.OrdinalIgnoreCase) == true)
                    FilteredLogs.Add(m);
            }
        }
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\ViewModels\GrimoireManagerViewModel.cs ========================================
>> 
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.Mvvm.Messaging;
using CodexEngine.GrimoireCore.Models;
using System.Collections.ObjectModel;
using System;
using GPTExporterIndexerAvalonia.ViewModels.Messages;
using System.Linq; // <-- NEW USING

namespace GPTExporterIndexerAvalonia.ViewModels;

// Add the new IRecipient interface
public partial class GrimoireManagerViewModel : ObservableObject, IRecipient<AddNewRitualMessage>
{
    private readonly IMessenger _messenger;

    public ObservableCollection<Ritual> Rituals { get; } = new();
    public ObservableCollection<Ingredient> Ingredients { get; } = new();
    public ObservableCollection<Servitor> Servitors { get; } = new();

    public GrimoireManagerViewModel(IMessenger messenger)
    {
        _messenger = messenger;
        // This registers the ViewModel to receive any messages it implements an IRecipient for.
        _messenger.RegisterAll(this);
        // We also still need to notify the timeline when rituals change.
        Rituals.CollectionChanged += (s, e) => _messenger.Send(new RitualsChangedMessage());
    }

    [ObservableProperty]
    private Ritual? _selectedRitual;

    [ObservableProperty]
    private string? _ritualTitle;

    partial void OnSelectedRitualChanged(Ritual? value)
    {
        RitualTitle = value?.Title;
    }

    partial void OnRitualTitleChanged(string? value)
    {
        if (SelectedRitual != null && value != null)
        {
            SelectedRitual.Title = value;
        }
    }

    // This new method handles the incoming message from the MainWindowViewModel
    public void Receive(AddNewRitualMessage message)
    {
        var newRitual = message.Value;
        
        // Add the new ritual and re-sort the collection by date to maintain order
        Rituals.Add(newRitual);
        
        var sortedRituals = new ObservableCollection<Ritual>(Rituals.OrderBy(r => r.DateTime));
        Rituals.Clear();
        foreach (var r in sortedRituals)
        {
            Rituals.Add(r);
        }
    }

    [RelayCommand]
    private void AddRitual()
    {
        var newRitual = new Ritual
        {
            ID = Guid.NewGuid().ToString(),
            Title = "New Ritual",
            Content = string.Empty,
            DateTime = DateTime.Now.AddDays(7)
        };
        Rituals.Add(newRitual);
    }

    [RelayCommand]
    private void RemoveRitual()
    {
        if (SelectedRitual != null)
        {
            Rituals.Remove(SelectedRitual);
        }
    }

    [RelayCommand]
    private void AddIngredient()
    {
        Ingredients.Add(new Ingredient { Name = "New Ingredient", Category = "General" });
    }

    [RelayCommand]
    private void RemoveIngredient(Ingredient? ingredient)
    {
        if (ingredient != null) { Ingredients.Remove(ingredient); }
    }

    [RelayCommand]
    private void AddServitor()
    {
        Servitors.Add(new Servitor { Name = "New Servitor", Purpose = string.Empty, VisualDescription = string.Empty });
    }



    [RelayCommand]
    private void RemoveServitor(Servitor? servitor)
    {
        if (servitor != null) { Servitors.Remove(servitor); }
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\ViewModels\MainWindowViewModel.cs ========================================
>> 
// FILE: GPTExporterIndexerAvalonia/ViewModels/MainWindowViewModel.cs
// FINALIZED FOR PHASE 2
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using GPTExporterIndexerAvalonia.Helpers;
using CodexEngine.Parsing.Models;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.IO;
using System.Threading.Tasks;
using GPTExporterIndexerAvalonia.Services;
using System.Collections.Generic;
using System.Linq;
using Avalonia.Media.Imaging;
using GPTExporterIndexerAvalonia.Reading;
using System;
using CodexEngine.ExportEngine.Models;
using CodexEngine.ChatGPTLogManager.Models;
using CodexEngine.AmandaMapCore.Models;
using CodexEngine.GrimoireCore.Models;
using CodexEngine.Parsing;
using CommunityToolkit.Mvvm.Messaging; // <-- NEW USING
using GPTExporterIndexerAvalonia.ViewModels.Messages; // <-- NEW USING

namespace GPTExporterIndexerAvalonia.ViewModels;

public partial class MainWindowViewModel : ObservableObject
{
    // Services
    private readonly IMessenger _messenger; // <-- NEW FIELD
    private readonly IIndexingService _indexingService;
    private readonly ISearchService _searchService;
    private readonly IFileParsingService _fileParsingService;
    private readonly IDialogService _dialogService;
    private readonly IEntryParserService _entryParserService;

    // Sub-ViewModels for tabs
    public GrimoireManagerViewModel GrimoireViewModel { get; }
    public TimelineViewModel TimelineViewModel { get; }
    public AmandaMapViewModel AmandaMapViewModel { get; }
    public TagMapViewModel TagMapViewModel { get; }
    public YamlInterpreterViewModel YamlInterpreterViewModel { get; }
    public ChatLogViewModel ChatLogViewModel { get; }
    public RitualBuilderViewModel RitualBuilderViewModel { get; }
    
    // Properties for the UI
    [ObservableProperty] private string _indexFolder = string.Empty;
    [ObservableProperty] private string _status = "Ready.";
    [ObservableProperty] private string _query = string.Empty;
    [ObservableProperty] private bool _caseSensitive;
    [ObservableProperty] private bool _useFuzzy;
    [ObservableProperty] private bool _useAnd = true;
    [ObservableProperty] private int _contextLines = 1;
    [ObservableProperty] private SearchResult? _selectedResult;
    [ObservableProperty] private string _selectedFile = string.Empty;
    [ObservableProperty] private string _parseFilePath = string.Empty;
    [ObservableProperty] private string _parseStatus = string.Empty;
    [ObservableProperty] private string _documentPath = string.Empty;
    [ObservableProperty] private string _bookFile = string.Empty;
    [ObservableProperty] private string _bookContent = string.Empty;
    [ObservableProperty] private string _indexContent = "Index has not been viewed yet. Click 'View Index' to load it.";
    [ObservableProperty] private string? _selectedFileContent;

    public ObservableCollection<Bitmap> Pages { get; } = new();
    private readonly BookReader _reader = new();
    public ObservableCollection<BaseMapEntry> ParsedEntries { get; } = new();
    public ObservableCollection<SearchResult> Results { get; } = new();

    public MainWindowViewModel(
        IMessenger messenger, // <-- INJECT THE MESSENGER
        IIndexingService indexingService, 
        ISearchService searchService, 
        IFileParsingService fileParsingService,
        IDialogService dialogService,
        IEntryParserService entryParserService,
        GrimoireManagerViewModel grimoireViewModel,
        TimelineViewModel timelineViewModel,
        AmandaMapViewModel amandaMapViewModel,
        TagMapViewModel tagMapViewModel,
        YamlInterpreterViewModel yamlInterpreterViewModel,
        ChatLogViewModel chatLogViewModel,
        RitualBuilderViewModel ritualBuilderViewModel)
    {
        _messenger = messenger; // <-- ASSIGN THE MESSENGER
        _indexingService = indexingService;
        _searchService = searchService;
        _fileParsingService = fileParsingService;
        _dialogService = dialogService;
        _entryParserService = entryParserService;

        GrimoireViewModel = grimoireViewModel;
        TimelineViewModel = timelineViewModel;
        AmandaMapViewModel = amandaMapViewModel;
        TagMapViewModel = tagMapViewModel;
        YamlInterpreterViewModel = yamlInterpreterViewModel;
        ChatLogViewModel = chatLogViewModel;
        RitualBuilderViewModel = ritualBuilderViewModel;
        
        DebugLogger.Log("MainWindowViewModel created and all services/sub-ViewModels injected.");
    }

    partial void OnSelectedResultChanged(SearchResult? value)
    {
        if (value is null)
        {
            SelectedFile = string.Empty;
            SelectedFileContent = null;
            return;
        }

        SelectedFile = Path.Combine(IndexFolder, value.File);
        try
        {
            SelectedFileContent = File.ReadAllText(SelectedFile);
        }
        catch (Exception ex)
        {
            SelectedFileContent = $"Error reading file: {ex.Message}";
        }
    }

    [RelayCommand]
    private void ProcessAsRitual()
    {
        if (string.IsNullOrWhiteSpace(SelectedFileContent)) return;

        var parsedObject = _entryParserService.ParseEntry(SelectedFileContent);
        if (parsedObject is Ritual ritual)
        {
            DebugLogger.Log($"Successfully parsed as Ritual: {ritual.Title}. Sending to Grimoire.");
            Status = $"Parsed Ritual: {ritual.Title}. Sending to Grimoire.";
            // SEND THE MESSAGE
            _messenger.Send(new AddNewRitualMessage(ritual));
        }
        else
        {
            DebugLogger.Log("Could not parse selection as a Ritual.");
            Status = "Could not parse selection as a Ritual.";
        }
    }

    [RelayCommand]
    private void ProcessAsAmandaMapEntry()
    {
        if (string.IsNullOrWhiteSpace(SelectedFileContent)) return;

        var parsedObject = _entryParserService.ParseEntry(SelectedFileContent);
        if (parsedObject is NumberedMapEntry entry)
        {
            DebugLogger.Log($"Successfully parsed as {entry.EntryType}: #{entry.Number} - {entry.Title}. Sending to AmandaMap.");
            Status = $"Parsed {entry.EntryType}: #{entry.Number}. Sending to AmandaMap.";
            // SEND THE MESSAGE
            _messenger.Send(new AddNewAmandaMapEntryMessage(entry));
        }
        else
        {
            DebugLogger.Log("Could not parse selection as an AmandaMap Entry.");
            Status = "Could not parse selection as an AmandaMap Entry.";
        }
    }
    
    [RelayCommand]
    private async Task BuildIndex()
    {
        DebugLogger.Log("MainWindowViewModel: 'Build Index' command initiated.");
        var folderPath = await _dialogService.ShowOpenFolderDialogAsync("Select Folder to Index");
        if (string.IsNullOrWhiteSpace(folderPath))
        {
            Status = "Index operation cancelled.";
            DebugLogger.Log("MainWindowViewModel: Folder selection was cancelled.");
            return;
        }

        IndexFolder = folderPath;
        Status = $"Building index for '{Path.GetFileName(IndexFolder)}'...";
        await _indexingService.BuildIndexAsync(IndexFolder, true);
        Status = "Index build complete.";
        DebugLogger.Log($"MainWindowViewModel: Index build process completed for folder: {IndexFolder}");
    }

    [RelayCommand]
    private async Task Search()
    {
        Status = $"Searching for '{Query}'...";
        DebugLogger.Log($"MainWindowViewModel: Kicking off search for query: '{Query}'");
        Results.Clear();
        var opts = new SearchOptions { CaseSensitive = CaseSensitive, UseFuzzy = UseFuzzy, UseAnd = UseAnd, ContextLines = ContextLines };
        var indexPath = Path.Combine(IndexFolder, "index.json");
        if (!File.Exists(indexPath))
        {
            Status = "Index not found. Please build the index first.";
            DebugLogger.Log($"MainWindowViewModel: Search failed, index not found at '{indexPath}'.");
            return;
        }

        var searchResults = await _searchService.SearchAsync(indexPath, Query, opts);
        foreach (var result in searchResults)
        {
            Results.Add(result);
        }
        Status = $"Search complete. Found {Results.Count} files.";
        DebugLogger.Log($"MainWindowViewModel: Search complete. Found {Results.Count} files.");
    }

    [RelayCommand]
    private void OpenSelected()
    {
        if (SelectedResult == null) return;
        var path = Path.Combine(IndexFolder, SelectedResult.File);
        DebugLogger.Log($"MainWindowViewModel: Attempting to open file: {path}");
        try
        {
            Process.Start(new ProcessStartInfo(path) { UseShellExecute = true });
        }
        catch (Exception ex) 
        { 
            Status = $"Error opening file: {ex.Message}";
            DebugLogger.Log($"MainWindowViewModel: Error opening file '{path}'. Error: {ex.Message}");
        }
    }

    [RelayCommand]
    private async Task ParseFile()
    {
        var filePath = await _dialogService.ShowOpenFileDialogAsync("Select File to Parse", 
            new FileFilter("Parsable Files", new []{ "json", "md", "txt" }));
        if (string.IsNullOrWhiteSpace(filePath) || !File.Exists(filePath))
        {
            ParseStatus = "Parse operation cancelled.";
            DebugLogger.Log("MainWindowViewModel: File parsing was cancelled.");
            return;
        }

        ParseFilePath = filePath;
        ParseStatus = $"Parsing '{Path.GetFileName(ParseFilePath)}'...";
        DebugLogger.Log($"MainWindowViewModel: Parsing file: {ParseFilePath}");
        ParsedEntries.Clear();
        var entries = await _fileParsingService.ParseFileAsync(ParseFilePath);
        foreach (var e in entries) ParsedEntries.Add(e);
        ParseStatus = $"Parsed {ParsedEntries.Count} entries.";
        DebugLogger.Log($"MainWindowViewModel: Parsing complete. Found {ParsedEntries.Count} entries.");
    }

    [RelayCommand]
    private async Task ExportSummary()
    {
        if (!ParsedEntries.Any())
        {
            ParseStatus = "Nothing to export.";
            return;
        }
        ParseStatus = "Exporting summary...";
        DebugLogger.Log("MainWindowViewModel: Kicking off summary export.");
        var outputFilePath = await _fileParsingService.ExportSummaryAsync(ParsedEntries, ParseFilePath);

        if (!string.IsNullOrEmpty(outputFilePath))
        {
            ParseStatus = $"Summary exported to {Path.GetFileName(outputFilePath)}";
            DebugLogger.Log($"MainWindowViewModel: Summary export successful to {outputFilePath}");
        }
        else
        {
            ParseStatus = "Failed to export summary.";
            DebugLogger.Log("MainWindowViewModel: Summary export failed.");
        }
    }
    
    [RelayCommand]
    void ViewIndex()
    {
        var indexPath = Path.Combine(IndexFolder, "index.json");
        if (string.IsNullOrEmpty(IndexFolder) || !File.Exists(indexPath))
        {
            IndexContent = "Could not find index.json. Please build the index first.";
            return;
        }

        try
        {
            IndexContent = File.ReadAllText(indexPath);
        }
        catch (Exception ex)
        {
            IndexContent = $"Failed to read index file.\n\nError: {ex.Message}";
        }
    }
    
    [RelayCommand]
    private async Task LoadDocument()
    {
        var filePath = await _dialogService.ShowOpenFileDialogAsync("Select Document to View",
            new FileFilter("Documents", new []{ "pdf", "md", "txt", "docx", "json" }));
        if (string.IsNullOrWhiteSpace(filePath)) return;

        DocumentPath = filePath;
        Pages.Clear();
        _reader.Load(DocumentPath);
        foreach (var p in _reader.Pages) Pages.Add(p);
    }
    
    [RelayCommand]
    private async Task LoadBook()
    {
        var filePath = await _dialogService.ShowOpenFileDialogAsync("Select Book File",
            new FileFilter("Text-based Books", new []{ "txt", "md", "html" }));
        if (string.IsNullOrWhiteSpace(filePath) || !File.Exists(filePath))
        {
            BookContent = "Could not load book file.";
            return;
        }
        
        BookFile = filePath;
        BookContent = await File.ReadAllTextAsync(BookFile);
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\ViewModels\RitualBuilderViewModel.cs ========================================
>> 
// FILE: GPTExporterIndexerAvalonia/ViewModels/RitualBuilderViewModel.cs
// REFACTORED
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CodexEngine.RitualForge.Models;
using AvaloniaWebView;
using System.Threading.Tasks;
using System.IO;
using System;

namespace GPTExporterIndexerAvalonia.ViewModels;

/// <summary>
/// Manages the interaction with a WebView that hosts the Ritual Builder UI.
/// Handles saving and loading the ritual scene data to and from the local filesystem.
/// </summary>
public partial class RitualBuilderViewModel : ObservableObject
{
    /// <summary>
    /// A reference to the WebView control in the View. This should be set from the code-behind.
    /// </summary>
    public WebView? Builder { get; set; }

    /// <summary>
    /// Defines the path where the ritual scene data will be saved.
    //  Using a property for the path is more flexible than hardcoding it.
    /// </summary>
    public string ScenePath { get; } = Path.Combine(
        Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments),
        "ritual-scene.json"
    );

    [RelayCommand]
    private async Task Save()
    {
        // CONFLICT RESOLVED: Using 'Builder is null' is a cleaner, more modern null check.
        if (Builder is null)
        {
            return;
        }

        try
        {
            // Assumes the JavaScript function 'window.saveScene()' exists in the loaded HTML 
            // and returns the scene data as a JSON string.
            var result = await Builder.ExecuteScriptAsync("window.saveScene();");

            // Save the resulting JSON to the predefined ScenePath.
            await File.WriteAllTextAsync(ScenePath, result ?? "{}");
        }
        catch (Exception ex)
        {
            // TODO: Implement proper error logging or display a message to the user.
            Console.WriteLine($"Error saving ritual scene: {ex.Message}");
        }
    }

    [RelayCommand]
    private async Task Load()
    {
        if (Builder is null)
        {
            return;
        }

        if (!File.Exists(ScenePath))
        {
            // If the file doesn't exist, there's nothing to load.
            return;
        }

        try
        {
            var json = await File.ReadAllTextAsync(ScenePath);

            // Sanitize the JSON string for use in a JavaScript literal.
            var escapedJson = json
                .Replace("\\", "\\\\")
                .Replace("`", "\\`")
                .Replace("'", "\\'")
                .Replace("\"", "\\\"");

            // Construct the script to call the 'window.loadScene' function in the WebView.
            var script = $"window.loadScene(`{escapedJson}`);";

            await Builder.ExecuteScriptAsync(script);
        }
        catch (Exception ex)
        {
            // TODO: Implement proper error logging.
            Console.WriteLine($"Error loading ritual scene: {ex.Message}");
        }
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\ViewModels\TagMapViewModel.cs ========================================
>> 
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using System.Collections.ObjectModel;
using System.IO;
using System.Text.Json;
using System.Linq;
using System.Text.Json.Serialization;
using GPTExporterIndexerAvalonia.Reading;
using System;
using Avalonia.Controls;
using System.Diagnostics;
// Add these using statements
using GPTExporterIndexerAvalonia.Services;
using System.Threading.Tasks;

namespace GPTExporterIndexerAvalonia.ViewModels;
public partial class TagMapEntry
{
    public string Document { get; set; } = string.Empty;
    public string Category { get; set; } = string.Empty;
    public int? Line { get; set; }
    public string? Preview { get; set; }
    [JsonIgnore]
    public string? FilePath { get; set; }
}

public partial class TagMapDocument : ObservableObject
{
    public string Name { get; set; } = string.Empty;
    public ObservableCollection<TagMapEntry> Entries { get; } = new();
    public ObservableCollection<TagMapEntry> FilteredEntries { get; } = new();
}

public partial class TagMapViewModel : ObservableObject
{
    // Add the service field
    private readonly IDialogService _dialogService;

    [ObservableProperty]
    private string _filePath = "tagmap.json";
    [ObservableProperty]
    private string _selectedSnippet = string.Empty;
    [ObservableProperty]
    private string? _documentFilter;
    [ObservableProperty]
    private string? _categoryFilter;

    public ObservableCollection<TagMapDocument> Documents { get; } = new();
    public ObservableCollection<TagMapDocument> FilteredDocuments { get; } = new();
    
    // Inject the service in the constructor
    public TagMapViewModel(IDialogService dialogService)
    {
        _dialogService = dialogService;
    }

    partial void OnDocumentFilterChanged(string? value) => FilterDocuments();
    partial void OnCategoryFilterChanged(string? value) => FilterDocuments();

    // New command to handle Browse
    [RelayCommand]
    private async Task BrowseAndLoad()
    {
        var filter = new FileFilter("TagMap Files", new[] { "json", "csv", "xlsx" });
        var path = await _dialogService.ShowOpenFileDialogAsync("Select TagMap File", filter);

        if (!string.IsNullOrWhiteSpace(path))
        {
            FilePath = path;
            Load(); // Call the existing Load method
        }
    }

    [RelayCommand]
    private void Load()
    {
        Documents.Clear();
        if (string.IsNullOrWhiteSpace(FilePath) || !File.Exists(FilePath))
            return;
        try
        {
            var entries = TagMapImporter.Load(FilePath);
            if (entries == null) return;

            var baseDir = Path.GetDirectoryName(FilePath) ?? string.Empty;
            foreach (var group in entries.GroupBy(e => e.Document))
            {
                var doc = new TagMapDocument { Name = group.Key ?? string.Empty };
                foreach (var e in group)
                {
                    e.FilePath = Path.IsPathRooted(e.Document) ? e.Document : Path.Combine(baseDir, e.Document);
                    doc.Entries.Add(e);
                }
                Documents.Add(doc);
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Failed to load tag map: {ex.Message}");
        }
        FilterDocuments();
    }
    
    // ... all other methods (Save, AddDocument, etc.) remain the same
    [RelayCommand]
    private void Save()
    {
        var list = Documents.SelectMany(d => d.Entries.Select(e => new TagMapEntry
        {
            Document = d.Name,
            Category = e.Category,
            Line = e.Line,
            Preview = e.Preview
        })).ToList();
        var json = JsonSerializer.Serialize(list, new JsonSerializerOptions { WriteIndented = true });
        File.WriteAllText(FilePath, json);
    }

    [RelayCommand]
    private void AddDocument()
    {
        Documents.Add(new TagMapDocument { Name = "New Document" });
        FilterDocuments();
    }

    [RelayCommand]
    private void AddEntry(TagMapDocument? document)
    {
        if (document == null) return;
        var baseDir = Path.GetDirectoryName(FilePath) ?? string.Empty;
        var entry = new TagMapEntry { Category = "General", Document = document.Name };
        entry.FilePath = Path.IsPathRooted(entry.Document)
            ? entry.Document
            : Path.Combine(baseDir, entry.Document);

        document.Entries.Add(entry);
        FilterDocuments();
    }
    
    [RelayCommand]
    private void PreviewEntry(TagMapEntry? entry)
    {
        if (entry == null) return;
        if (string.IsNullOrEmpty(entry.FilePath))
        {
            var baseDir = Path.GetDirectoryName(FilePath) ?? string.Empty;
            entry.FilePath = Path.IsPathRooted(entry.Document)
                ? entry.Document
                : Path.Combine(baseDir, entry.Document);
        }

        if (!File.Exists(entry.FilePath))
        {
            SelectedSnippet = $"File not found: {entry.FilePath}";
            return;
        }

        try
        {
            var lines = File.ReadAllLines(entry.FilePath);
            if (entry.Line.HasValue)
            {
                int line = Math.Clamp(entry.Line.Value - 1, 0, lines.Length - 1);
                int start = Math.Max(0, line - 2);
                int end = Math.Min(lines.Length - 1, line + 2);
                SelectedSnippet = string.Join("\n", lines[start..(end + 1)]);
            }
            else
            {
                SelectedSnippet = string.Join("\n", lines.Take(5));
            }
        }
        catch (Exception ex)
        {
            SelectedSnippet = $"Error reading file: {ex.Message}";
        }
    }

    [RelayCommand]
    private void OpenEntryInEditor(TagMapEntry? entry)
    {
        if (entry == null || string.IsNullOrWhiteSpace(entry.Document)) return;
        try
        {
            string path_to_open = entry.FilePath ?? entry.Document;

            if (File.Exists(path_to_open))
            {
                var ext = Path.GetExtension(path_to_open).ToLowerInvariant();
                if (ext == ".txt" || ext == ".md" || ext == ".json")
                {
                    var window = new Window
                    {
                        Width = 800,
                        Height = 600,
                        Title = Path.GetFileName(path_to_open)
                    };
                    var textBox = new TextBox
                    {
                        IsReadOnly = true,
                        AcceptsReturn = true,
                        Text = File.ReadAllText(path_to_open)
                    };
                    window.Content = textBox;
                    window.Show();
                }
                else
                {
                    Process.Start(new ProcessStartInfo(path_to_open) { UseShellExecute = true });
                }
            }
            else
            {
                 Debug.WriteLine($"File not found, cannot open: {path_to_open}");
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Error opening entry: {ex.Message}");
        }
    }

    private void FilterDocuments()
    {
        FilteredDocuments.Clear();
        foreach (var doc in Documents)
        {
            if (!string.IsNullOrWhiteSpace(DocumentFilter) &&
                !doc.Name.Contains(DocumentFilter, StringComparison.OrdinalIgnoreCase))
                continue;
            doc.FilteredEntries.Clear();
            var filtered = doc.Entries.Where(entry =>
                string.IsNullOrWhiteSpace(CategoryFilter) ||
                entry.Category.Contains(CategoryFilter, StringComparison.OrdinalIgnoreCase)
            );
            foreach(var entry in filtered)
            {
                doc.FilteredEntries.Add(entry);
            }
            
            if(doc.FilteredEntries.Any())
            {
                 FilteredDocuments.Add(doc);
            }
        }
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\ViewModels\TimelineViewModel.cs ========================================
>> 
// REFACTORED
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Messaging; // New using
using CodexEngine.GrimoireCore.Models;
using System;
using System.Collections.ObjectModel;
using System.Linq;
using GPTExporterIndexerAvalonia.ViewModels.Messages; // New using

namespace GPTExporterIndexerAvalonia.ViewModels;

public partial class TimelineViewModel : ObservableObject, IRecipient<RitualsChangedMessage>
{
    private readonly GrimoireManagerViewModel _grimoireManager;

    [ObservableProperty]
    private DateTime _selectedDate = DateTime.Today;

    public ObservableCollection<Ritual> Upcoming { get; } = new();

    public TimelineViewModel(IMessenger messenger, GrimoireManagerViewModel grimoireManager)
    {
        _grimoireManager = grimoireManager;
        messenger.RegisterAll(this); // Register for messages
        Refresh();
    }

    // Receive the message that rituals have changed
    public void Receive(RitualsChangedMessage message)
    {
        Refresh(); // Re-run the filter logic
    }

    /// <summary>
    /// Refreshes the list of upcoming rituals.
    /// </summary>
    public void Refresh()
    {
        Upcoming.Clear();

        var rituals = _grimoireManager.Rituals;

        foreach (var r in rituals.Where(r => r.DateTime.Date >= DateTime.Today).OrderBy(r => r.DateTime))
        {
            Upcoming.Add(r);
        }
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\ViewModels\YamlInterpreterViewModel.cs ========================================
>> 
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using System.Collections.ObjectModel;
using System.Collections.Generic;
using System.IO;
using YamlDotNet.Serialization;

namespace GPTExporterIndexerAvalonia.ViewModels;

public class YamlNode : ObservableObject
{
    public string Name { get; set; } = string.Empty;
    public string? Value { get; set; }
    public ObservableCollection<YamlNode> Children { get; } = new();

    public string Display => string.IsNullOrEmpty(Value) ? Name : $"{Name}: {Value}";
}

public partial class YamlInterpreterViewModel : ObservableObject
{
    [ObservableProperty]
    private string _filePath = string.Empty;

    public ObservableCollection<YamlNode> Items { get; } = new();

    [RelayCommand]
    private void Load()
    {
        Items.Clear();
        if (string.IsNullOrWhiteSpace(FilePath) || !File.Exists(FilePath))
            return;
        try
        {
            var text = File.ReadAllText(FilePath);
            var deserializer = new DeserializerBuilder().Build();
            var obj = deserializer.Deserialize<object>(text);
            if (obj != null)
            {
                var node = ConvertToNode("root", obj);
                foreach (var child in node.Children)
                    Items.Add(child);
            }
        }
        catch { }
    }

    private static YamlNode ConvertToNode(string name, object value)
    {
        var node = new YamlNode { Name = name };
        switch (value)
        {
            case IDictionary<object, object> dict:
                foreach (var kvp in dict)
                {
                    var child = ConvertToNode(kvp.Key.ToString() ?? "", kvp.Value!);
                    node.Children.Add(child);
                }
                break;
            case IList<object> list:
                int index = 0;
                foreach (var item in list)
                {
                    var child = ConvertToNode($"[{index}]", item);
                    node.Children.Add(child);
                    index++;
                }
                break;
            default:
                node.Value = value?.ToString();
                break;
        }
        return node;
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Views\Controls\BookViewer.axaml ========================================
>> 
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             x:Class="GPTExporterIndexerAvalonia.Views.Controls.BookViewer">
    <Border Padding="8" BorderThickness="2" CornerRadius="8"
            BorderBrush="Violet" Background="#220022">
        <ContentControl x:Name="PART_Content" />
    </Border>
</UserControl>

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Views\Controls\BookViewer.axaml.cs ========================================
>> 
using Avalonia;
using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using GPTExporterIndexerAvalonia.Reading;
using DocumentFormat.OpenXml.Packaging;
using System.IO;
using VersOne.Epub;
using TheArtOfDev.HtmlRenderer.Avalonia;
using Avalonia.Media;
using System.Linq;
using System;
using System.Text; // Required for StringBuilder

namespace GPTExporterIndexerAvalonia.Views.Controls;

/// <summary>
/// A versatile UserControl for displaying various document types,
/// including PDF, DOCX, EPUB, Markdown, and JSON files.
/// </summary>
public partial class BookViewer : UserControl
{
    public static readonly StyledProperty<string?> FilePathProperty =
        AvaloniaProperty.Register<BookViewer, string?>(nameof(FilePath));

    /// <summary>
    /// Gets or sets the path to the file to be displayed.
    /// When this property is changed, the control automatically loads and renders the new file.
    /// </summary>
    public string? FilePath
    {
        get => GetValue(FilePathProperty);
        set => SetValue(FilePathProperty, value);
    }

    private readonly ContentControl _content;

    public BookViewer()
    {
        InitializeComponent();
        _content = this.FindControl<ContentControl>("PART_Content")
            ?? throw new InvalidOperationException("Could not find PART_Content in the control template.");

        // Subscribe to changes on the FilePath property to automatically load files.
        this.GetObservable(FilePathProperty).Subscribe(LoadFile);
    }

    private void InitializeComponent()
    {
        AvaloniaXamlLoader.Load(this);
    }

    /// <summary>
    /// Main dispatcher method that loads a file based on its extension.
    /// </summary>
    private void LoadFile(string? path)
    {
        if (string.IsNullOrEmpty(path) || !File.Exists(path))
        {
            _content.Content = null;
            return;
        }

        var ext = Path.GetExtension(path).ToLowerInvariant();

        // Using a switch expression for a cleaner dispatch logic.
        _content.Content = ext switch
        {
            ".pdf" => CreatePdfView(path),
            ".docx" => CreateDocxView(path),
            ".epub" => CreateEpubView(path),
            ".md" => CreateTextView(path), // Markdown is treated as plain text for now
            ".json" => CreateTextView(path, useMonospace: true), // JSON benefits from monospaced font
            ".mobi" or _ => CreateUnsupportedView(ext), // .mobi is not supported
        };
    }

    /// <summary>
    /// Creates a view for displaying PDF files as a series of images.
    /// </summary>
    private Control CreatePdfView(string path)
    {
        try
        {
            var reader = new BookReader();
            reader.Load(path); // Assumes this class handles PDF reading
            var panel = new StackPanel();
            foreach (var bmp in reader.Pages)
            {
                panel.Children.Add(new Image
                {
                    Source = bmp,
                    Stretch = Stretch.Uniform,
                    Margin = new Thickness(0, 5)
                });
            }
            return new ScrollViewer { Content = panel };
        }
        catch (Exception ex)
        {
            return CreateErrorView("PDF", ex);
        }
    }

    /// <summary>
    /// Creates a view for displaying the text content of a .docx file.
    /// </summary>
    private Control CreateDocxView(string path)
    {
        try
        {
            using var doc = WordprocessingDocument.Open(path, false);
            var text = doc.MainDocumentPart?.Document.Body?.InnerText ?? "Could not read document body.";
            var textBlock = new TextBlock { Text = text, TextWrapping = TextWrapping.Wrap, Margin = new Thickness(5) };
            return new ScrollViewer { Content = textBlock };
        }
        catch (Exception ex)
        {
            return CreateErrorView("DOCX", ex);
        }
    }

    /// <summary>
    /// Creates a view for displaying the combined HTML content of an .epub file.
    /// </summary>
    private Control CreateEpubView(string path)
    {
        try
        {
            var book = EpubReader.ReadBook(path);
            var contentBuilder = new StringBuilder();

            // Concatenate all local HTML content from the EPUB into one string.
            foreach (var htmlFile in book.Content.Html.Local)
            {
                contentBuilder.AppendLine(htmlFile.Content);
                contentBuilder.AppendLine("<hr />"); // Add a separator between chapters
            }

            return new HtmlControl { Text = contentBuilder.ToString() };
        }
        catch (Exception ex)
        {
            return CreateErrorView("EPUB", ex);
        }
    }

    /// <summary>
    /// Creates a view for displaying plain text files like .md and .json.
    /// </summary>
    private Control CreateTextView(string path, bool useMonospace = false)
    {
        try
        {
            var text = File.ReadAllText(path);
            var textBox = new TextBox
            {
                Text = text,
                IsReadOnly = true,
                AcceptsReturn = true,
                TextWrapping = TextWrapping.Wrap,
                // Avalonia handles scroll bars via ScrollViewer. Keep default behaviour.
            };

            if (useMonospace)
            {
                textBox.FontFamily = new FontFamily("Cascadia Mono,Consolas,Menlo,monospace");
            }

            return textBox;
        }
        catch (Exception ex)
        {
            return CreateErrorView("Text File", ex);
        }
    }

    /// <summary>
    /// Creates a view indicating that the file format is not supported.
    /// </summary>
    private Control CreateUnsupportedView(string extension)
    {
        // Note: .mobi is a complex binary format requiring specialized libraries to parse.
        // It is grouped here as unsupported for simplicity.
        return new TextBlock
        {
            Text = $"The file format '{extension}' is not supported.",
            HorizontalAlignment = Avalonia.Layout.HorizontalAlignment.Center,
            VerticalAlignment = Avalonia.Layout.VerticalAlignment.Center
        };
    }

    /// <summary>
    /// Creates a standardized view for displaying file loading errors.
    /// </summary>
    private Control CreateErrorView(string format, Exception ex)
    {
        return new TextBlock
        {
            Text = $"Failed to load {format} file.\n\nError: {ex.Message}",
            Foreground = new SolidColorBrush(Colors.Red),
            HorizontalAlignment = Avalonia.Layout.HorizontalAlignment.Center,
            VerticalAlignment = Avalonia.Layout.VerticalAlignment.Center,
            TextWrapping = TextWrapping.Wrap
        };
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Views\Yaml\YamlInterpreterView.axaml ========================================
>> 
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="clr-namespace:GPTExporterIndexerAvalonia.ViewModels"
             x:Class="GPTExporterIndexerAvalonia.Views.Yaml.YamlInterpreterView"
             DataContext="{Binding YamlInterpreterViewModel}">
    <Design.DataContext>
        <vm:YamlInterpreterViewModel />
    </Design.DataContext>
    <StackPanel Margin="10" Spacing="5">
        <StackPanel Orientation="Horizontal" Spacing="5">
            <TextBox Width="220" Watermark="YAML File" Text="{Binding FilePath}" />
            <Button Content="Load" Command="{Binding LoadCommand}" />
        </StackPanel>
        <TreeView ItemsSource="{Binding Items}">
            <TreeView.ItemTemplate>
                <TreeDataTemplate ItemsSource="{Binding Children}">
                    <TextBlock Text="{Binding Display}" />
                </TreeDataTemplate>
            </TreeView.ItemTemplate>
        </TreeView>
    </StackPanel>
</UserControl>

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Views\Yaml\YamlInterpreterView.axaml.cs ========================================
>> 
using Avalonia.Controls;
using Avalonia.Markup.Xaml;

namespace GPTExporterIndexerAvalonia.Views.Yaml;

public partial class YamlInterpreterView : UserControl
{
    public YamlInterpreterView()
    {
        InitializeComponent();
    }

    private void InitializeComponent()
    {
        AvaloniaXamlLoader.Load(this);
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Views\AmandaMapView.axaml ========================================
>> 
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="clr-namespace:GPTExporterIndexerAvalonia.ViewModels"
             x:Class="GPTExporterIndexerAvalonia.Views.AmandaMapView"
             DataContext="{Binding AmandaMapViewModel}">
    <Design.DataContext>
        <vm:AmandaMapViewModel />
    </Design.DataContext>
    <StackPanel Margin="10" Spacing="5">
        <StackPanel Orientation="Horizontal" Spacing="5">
            <TextBox Width="200" Watermark="File Path" Text="{Binding FilePath}" />
            <Button Content="Browse" Command="{Binding BrowseAndLoadCommand}" />
        </StackPanel>
        <Button Content="Load" Command="{Binding LoadCommand}" />
        <ScrollViewer Height="250">
            <ItemsControl ItemsSource="{Binding Entries}" >
                <ItemsControl.ItemTemplate>
                    <DataTemplate>
                        <Border BorderBrush="Violet" BorderThickness="1" Margin="2" Padding="2">
                             <TextBlock Text="{Binding Title}" />
                        </Border>
                    </DataTemplate>
                </ItemsControl.ItemTemplate>
            </ItemsControl>
        </ScrollViewer>
    </StackPanel>
</UserControl>

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Views\AmandaMapView.axaml.cs ========================================
>> 
using Avalonia.Controls;
using Avalonia.Markup.Xaml;

namespace GPTExporterIndexerAvalonia.Views;

public partial class AmandaMapView : UserControl
{
    public AmandaMapView()
    {
        InitializeComponent();
    }

    private void InitializeComponent()
    {
        AvaloniaXamlLoader.Load(this);
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Views\ChatLogView.axaml ========================================
>> 
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="clr-namespace:GPTExporterIndexerAvalonia.ViewModels"
             x:Class="GPTExporterIndexerAvalonia.Views.ChatLogView"
             DataContext="{Binding ChatLogViewModel}">
    <Design.DataContext>
        <vm:ChatLogViewModel />
    </Design.DataContext>
    <StackPanel Margin="10" Spacing="5">
        <Button Content="Load" Command="{Binding LoadCommand}" />
        <TextBox Watermark="Filter" Text="{Binding Filter}" />
        <ListBox ItemsSource="{Binding FilteredLogs}">
            <ListBox.ItemTemplate>
                <DataTemplate>
                    <TextBlock Text="{Binding Content}" TextWrapping="Wrap" />
                </DataTemplate>
            </ListBox.ItemTemplate>
        </ListBox>
    </StackPanel>
</UserControl>

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Views\ChatLogView.axaml.cs ========================================
>> 
using Avalonia.Controls;
using Avalonia.Markup.Xaml;

namespace GPTExporterIndexerAvalonia.Views;

public partial class ChatLogView : UserControl
{
    public ChatLogView()
    {
        InitializeComponent();
    }

    private void InitializeComponent()
    {
        AvaloniaXamlLoader.Load(this);
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Views\GrimoireManagerView.axaml ========================================
>> 
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="clr-namespace:GPTExporterIndexerAvalonia.ViewModels"
             x:Class="GPTExporterIndexerAvalonia.Views.GrimoireManagerView"
             DataContext="{Binding GrimoireViewModel}">
    <Design.DataContext>
        <vm:GrimoireManagerViewModel />
    </Design.DataContext>
    <StackPanel Margin="10" Spacing="5">
        <ListBox ItemsSource="{Binding Rituals}" SelectedItem="{Binding SelectedRitual}">
            <ListBox.ItemTemplate>
                <DataTemplate>
                    <TextBlock Text="{Binding Title}" />
                </DataTemplate>
            </ListBox.ItemTemplate>
        </ListBox>
        <TextBlock Text="Title" />
        <TextBox Text="{Binding RitualTitle}" />
        <Button Content="Add" Command="{Binding AddRitualCommand}" />
        <Button Content="Remove" Command="{Binding RemoveRitualCommand}" />

        <TextBlock Text="Ingredients" Margin="0,10,0,0" FontWeight="Bold" />
        <ListBox ItemsSource="{Binding Ingredients}">
            <ListBox.ItemTemplate>
                <DataTemplate>
                    <StackPanel Orientation="Horizontal" Spacing="5">
                        <TextBox Width="150" Text="{Binding Name}" />
                        <Button Content="X" Command="{Binding DataContext.RemoveIngredientCommand, RelativeSource={RelativeSource AncestorType=UserControl}}" CommandParameter="{Binding}" />
                    </StackPanel>
                </DataTemplate>
            </ListBox.ItemTemplate>
        </ListBox>
        <Button Content="Add Ingredient" Command="{Binding AddIngredientCommand}" />

        <TextBlock Text="Servitors" Margin="0,10,0,0" FontWeight="Bold" />
        <ListBox ItemsSource="{Binding Servitors}">
            <ListBox.ItemTemplate>
                <DataTemplate>
                    <StackPanel Orientation="Horizontal" Spacing="5">
                        <TextBox Width="150" Text="{Binding Name}" />
                        <Button Content="X" Command="{Binding DataContext.RemoveServitorCommand, RelativeSource={RelativeSource AncestorType=UserControl}}" CommandParameter="{Binding}" />
                    </StackPanel>
                </DataTemplate>
            </ListBox.ItemTemplate>
        </ListBox>
        <Button Content="Add Servitor" Command="{Binding AddServitorCommand}" />
    </StackPanel>
</UserControl>

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Views\GrimoireManagerView.axaml.cs ========================================
>> 
using Avalonia.Controls;
using Avalonia.Markup.Xaml;

namespace GPTExporterIndexerAvalonia.Views;

public partial class GrimoireManagerView : UserControl
{
    public GrimoireManagerView()
    {
        InitializeComponent();
    }

    private void InitializeComponent()
    {
        AvaloniaXamlLoader.Load(this);
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Views\MainWindow.axaml ========================================
>> 
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/avaloniaui"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:vm="clr-namespace:GPTExporterIndexerAvalonia.ViewModels"
        xmlns:views="clr-namespace:GPTExporterIndexerAvalonia.Views"
        xmlns:yaml="clr-namespace:GPTExporterIndexerAvalonia.Views.Yaml"
        xmlns:loc="clr-namespace:GPTExporterIndexerAvalonia"
        mc:Ignorable="d"
        x:Class="GPTExporterIndexerAvalonia.Views.MainWindow"
        Width="1200" Height="800"
        Title="Phoenix Codex">

    <DockPanel>
        <Border Padding="5" BorderThickness="2" BorderBrush="Purple" CornerRadius="8">
            <!-- 
              FIXED: The TabControl now binds to the Tabs collection in the MainWindowViewModel.
              The ViewLocator (defined in App.axaml) will automatically find the correct
              View for each ViewModel in the collection.
            -->
            <TabControl>
                <TabControl.DataTemplates>
                    <loc:ViewLocator/>
                </TabControl.DataTemplates>
                <TabItem Header="Index &amp; Search">
                    <views:MainWindowView/>
                </TabItem>
                <TabItem Header="Grimoire">
                    <views:GrimoireManagerView/>
                </TabItem>
                <TabItem Header="Timeline">
                    <views:TimelineView/>
                </TabItem>
                <TabItem Header="AmandaMap">
                    <views:AmandaMapView/>
                </TabItem>
                <TabItem Header="TagMap">
                    <views:TagMapView/>
                </TabItem>
                <TabItem Header="YAML Interpreter">
                    <yaml:YamlInterpreterView/>
                </TabItem>
                <TabItem Header="Chat Logs">
                    <views:ChatLogView/>
                </TabItem>
                 <TabItem Header="Ritual Builder">
                    <views:RitualBuilderView/>
                </TabItem>
            </TabControl>
        </Border>
    </DockPanel>
</Window>

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Views\MainWindow.axaml.cs ========================================
>> 
using Avalonia.Controls;
using Avalonia.Markup.Xaml;

namespace GPTExporterIndexerAvalonia.Views;

/// <summary>
/// Code-behind for <see cref="MainWindow.axaml"/>.
/// </summary>
public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();
    }

    private void InitializeComponent()
    {
        AvaloniaXamlLoader.Load(this);
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Views\MainWindowView.axaml ========================================
>> 
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:vm="clr-namespace:GPTExporterIndexerAvalonia.ViewModels"
             mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="600"
             x:Class="GPTExporterIndexerAvalonia.Views.MainWindowView">
    
    <Design.DataContext>
        <vm:MainWindowViewModel/>
    </Design.DataContext>

    <Grid ColumnDefinitions="4*,6*" RowDefinitions="*" Margin="10" >
        
        <DockPanel Grid.Column="0">
            <StackPanel DockPanel.Dock="Top" Spacing="5">
                <TextBox Text="{Binding Query, Mode=TwoWay}" Watermark="Enter search query..."/>
                <StackPanel Orientation="Horizontal" Spacing="10" HorizontalAlignment="Center">
                    <CheckBox Content="Case Sensitive" IsChecked="{Binding CaseSensitive}" />
                    <CheckBox Content="Fuzzy Match" IsChecked="{Binding UseFuzzy}" />
                    <Button Content="Search" Command="{Binding SearchCommand}" Classes="Primary"/>
                </StackPanel>
            </StackPanel>

            <ListBox ItemsSource="{Binding Results}" SelectedItem="{Binding SelectedResult}" Margin="0,10,0,0">
                <ListBox.ItemTemplate>
                    <DataTemplate>
                        <Border Classes="Card" Margin="0,0,5,5">
                            <StackPanel Spacing="3">
                                <TextBlock Text="{Binding File}" FontWeight="Bold" />
                                <TextBlock Text="{Binding Category}" FontStyle="Italic" Foreground="LightGray"/>
                                <TextBlock Text="{Binding Preview}" TextWrapping="Wrap" Foreground="Silver"/>
                            </StackPanel>
                        </Border>
                    </DataTemplate>
                </ListBox.ItemTemplate>
            </ListBox>
        </DockPanel>

        <DockPanel Grid.Column="1" Margin="10,0,0,0">
            <StackPanel DockPanel.Dock="Bottom" Orientation="Horizontal" Spacing="10" HorizontalAlignment="Right" Margin="0,10,0,0">
                <Button Content="Process as Ritual" Command="{Binding ProcessAsRitualCommand}" />
                <Button Content="Process as AmandaMap Entry" Command="{Binding ProcessAsAmandaMapEntryCommand}" Classes="Primary"/>
            </StackPanel>
            
            <ScrollViewer VerticalScrollBarVisibility="Auto" HorizontalScrollBarVisibility="Auto">
                <TextBox Text="{Binding SelectedFileContent}"
                         AcceptsReturn="True"
                         TextWrapping="Wrap"
                         IsReadOnly="True"
                         FontFamily="monospace"/>
            </ScrollViewer>
        </DockPanel>

    </Grid>
</UserControl>

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Views\MainWindowView.axaml.cs ========================================
>> 
using Avalonia.Controls;
using Avalonia.Markup.Xaml;

namespace GPTExporterIndexerAvalonia.Views;

public partial class MainWindowView : UserControl
{
    public MainWindowView()
    {
        InitializeComponent();
    }

    private void InitializeComponent()
    {
        AvaloniaXamlLoader.Load(this);
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Views\RitualBuilderView.axaml ========================================
>> 
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="https://github.com/avaloniaui"
             xmlns:vm="clr-namespace:GPTExporterIndexerAvalonia.ViewModels"
             xmlns:wv="clr-namespace:AvaloniaWebView;assembly=Avalonia.WebView"
             x:Class="GPTExporterIndexerAvalonia.Views.RitualBuilderView"
             DataContext="{Binding RitualBuilderViewModel}">
    <Design.DataContext>
        <vm:RitualBuilderViewModel />
    </Design.DataContext>
    <Grid>
        <wv:WebView Url="/WebAssets/ritual-builder.html" Name="Builder" />
        <Button Content="Save" HorizontalAlignment="Right" VerticalAlignment="Bottom" Margin="10" Command="{Binding SaveCommand}" />
    </Grid>
</UserControl>

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Views\RitualBuilderView.axaml.cs ========================================
>> 
// FILE: GPTExporterIndexerAvalonia/Views/RitualBuilderView.axaml.cs
// REFACTORED
using Avalonia.Controls;
using Avalonia.Interactivity; // FIXED: Added missing using directive
using Avalonia.Markup.Xaml;
using AvaloniaWebView;
using Avalonia;
using GPTExporterIndexerAvalonia.ViewModels;
using System;

namespace GPTExporterIndexerAvalonia.Views;

/// <summary>
/// The View for the Ritual Builder. This UserControl hosts the WebView
/// that contains the interactive builder interface. Its primary role is to
/// connect the WebView control from the XAML to the ViewModel.
/// </summary>
public partial class RitualBuilderView : UserControl
{
    public RitualBuilderView()
    {
        InitializeComponent();
    }

    private void InitializeComponent()
    {
        AvaloniaXamlLoader.Load(this);
    }

    /// <summary>
    /// Overridden to handle setup logic when the control is attached to the visual tree.
    /// This is a more reliable place to access the DataContext and controls than the constructor.
    /// </summary>
    protected override void OnAttachedToVisualTree(VisualTreeAttachmentEventArgs e)
    {
        base.OnAttachedToVisualTree(e);

        if (DataContext is RitualBuilderViewModel vm)
        {
            // Locate the WebView control defined in the XAML.
            var webView = this.FindControl<WebView>("Builder")
                ?? throw new InvalidOperationException("Could not find a WebView control named 'Builder' in the template.");

            // Assign the control instance to the ViewModel property so it can be controlled.
            vm.Builder = webView;
        }
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Views\TagMapView.axaml ========================================
>> 
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="clr-namespace:GPTExporterIndexerAvalonia.ViewModels"
             x:Class="GPTExporterIndexerAvalonia.Views.TagMapView"
             DataContext="{Binding TagMapViewModel}">
    <UserControl.Resources>
    </UserControl.Resources>
    
    <Design.DataContext>
        <vm:TagMapViewModel />
    </Design.DataContext>
    
    <StackPanel Margin="10" Spacing="5">
        <StackPanel Orientation="Horizontal" Spacing="5">
            <TextBox Width="200" Watermark="TagMap File" Text="{Binding FilePath}" />
            <Button Content="Browse" Command="{Binding BrowseAndLoadCommand}" />
            <Button Content="Load" Command="{Binding LoadCommand}" />
            <Button Content="Save" Command="{Binding SaveCommand}" />
            <Button Content="Add Doc" Command="{Binding AddDocumentCommand}" />
        </StackPanel>

        <StackPanel Orientation="Horizontal" Spacing="5">
            <TextBox Width="150" Watermark="Document Filter" Text="{Binding DocumentFilter}" />
            <TextBox Width="150" Watermark="Category Filter" Text="{Binding CategoryFilter}" />
        </StackPanel>

        <TabControl ItemsSource="{Binding FilteredDocuments}">
            <TabControl.ItemTemplate>
                <DataTemplate>
                    <TextBlock Text="{Binding Name}" />
                </DataTemplate>
            </TabControl.ItemTemplate>
            <TabControl.ContentTemplate>
                <DataTemplate>
                    <StackPanel Spacing="5" Margin="5">
                        <Button Content="Add Tag" Command="{Binding DataContext.AddEntryCommand, RelativeSource={RelativeSource AncestorType=TabControl}}" CommandParameter="{Binding}" />
                        
                        <ItemsControl ItemsSource="{Binding FilteredEntries}">
                            <ItemsControl.ItemTemplate>
                                <DataTemplate>
                                    <Border BorderBrush="DarkCyan" BorderThickness="1" Padding="5" Margin="2">
                                        <StackPanel Orientation="Horizontal" Spacing="5">
                                            <StackPanel Spacing="3">
                                                <TextBox Width="150" Text="{Binding Category}" Watermark="Category"/>
                                                <TextBox Width="200" Text="{Binding Preview}" Watermark="Preview Text"/>
                                            </StackPanel>
                                            <TextBox Width="50" Text="{Binding Line}" Watermark="Line"/>
                                            
                                            <StackPanel Spacing="3">
                                                <Button Content="Preview Snippet"
                                                          Command="{Binding DataContext.PreviewEntryCommand, RelativeSource={RelativeSource AncestorType=TabControl}}"
                                                          CommandParameter="{Binding}" />
                                                <Button Content="Open in Editor"
                                                          Command="{Binding DataContext.OpenEntryInEditorCommand, RelativeSource={RelativeSource AncestorType=TabControl}}"
                                                          CommandParameter="{Binding}" />
                                            </StackPanel>
                                        </StackPanel>
                                        </Border>
                                </DataTemplate>
                            </ItemsControl.ItemTemplate>
                        </ItemsControl>

                        <TextBlock Text="Snippet Preview:" Margin="0,10,0,0" FontWeight="Bold"/>
                        <TextBox Text="{Binding DataContext.SelectedSnippet, RelativeSource={RelativeSource AncestorType=TabControl}}"
                                 IsReadOnly="True" 
                                 AcceptsReturn="True" 
                                 Height="120" 
                                 TextWrapping="Wrap" 
                                 FontFamily="Cascadia Mono,Consolas,Menlo,monospace"/>
                    </StackPanel>
                </DataTemplate>
            </TabControl.ContentTemplate>
        </TabControl>
    </StackPanel>
</UserControl>

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Views\TagMapView.axaml.cs ========================================
>> 
using Avalonia.Controls;
using Avalonia.Markup.Xaml;

// Note: Unused 'using' statements have been removed.

namespace GPTExporterIndexerAvalonia.Views;
public partial class TagMapView : UserControl
{
    public TagMapView()
    {
        InitializeComponent();
    }

    private void InitializeComponent()
    {
        AvaloniaXamlLoader.Load(this);
    }

    // The entire "OnBrowse" method has been removed from this file.
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Views\TimelineView.axaml ========================================
>> 
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="clr-namespace:GPTExporterIndexerAvalonia.ViewModels"
             x:Class="GPTExporterIndexerAvalonia.Views.TimelineView"
             DataContext="{Binding TimelineViewModel}">
    <Design.DataContext>
        <vm:TimelineViewModel />
    </Design.DataContext>
    <StackPanel Margin="10" Spacing="5">
        <Calendar SelectedDate="{Binding SelectedDate}" />
        <TextBlock Text="Upcoming" FontWeight="Bold" Margin="0,5" />
        <ListBox ItemsSource="{Binding Upcoming}">
            <ListBox.ItemTemplate>
                <DataTemplate>
                    <TextBlock Text="{Binding Title}" />
                </DataTemplate>
            </ListBox.ItemTemplate>
        </ListBox>
    </StackPanel>
</UserControl>

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Views\TimelineView.axaml.cs ========================================
>> 
using Avalonia.Controls;
using Avalonia.Markup.Xaml;

namespace GPTExporterIndexerAvalonia.Views;

public partial class TimelineView : UserControl
{
    public TimelineView()
    {
        InitializeComponent();
    }

    private void InitializeComponent()
    {
        AvaloniaXamlLoader.Load(this);
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\App.axaml ========================================
>> 
<Application xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="using:GPTExporterIndexerAvalonia"
             x:Class="GPTExporterIndexerAvalonia.App"
             RequestedThemeVariant="Dark">
    <!--
      This Application.Resources section is crucial. It contains the ViewLocator,
      which tells the application how to find the correct View for any given ViewModel.
    -->
    <Application.Resources>
        <local:ViewLocator x:Key="ViewLocator"/>
    </Application.Resources>
    
    <Application.Styles>
        <FluentTheme />
        <StyleInclude Source="avares://GPTExporterIndexerAvalonia/Styles/MagicTheme.axaml" />
    </Application.Styles>
</Application>

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\App.axaml.cs ========================================
>> 
using Avalonia;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Markup.Xaml;
using CommunityToolkit.Mvvm.Messaging;
using CodexEngine.ExportEngine.Renderers;
using GPTExporterIndexerAvalonia.Services;
using GPTExporterIndexerAvalonia.ViewModels;
using GPTExporterIndexerAvalonia.Views;
using GPTExporterIndexerAvalonia.Views.Yaml;
using Microsoft.Extensions.DependencyInjection;
using System;
using CodexEngine.Parsing; // You may need to add this using statement

namespace GPTExporterIndexerAvalonia;

public partial class App : Application
{
    public new static App Current => (App)Application.Current!;
    public IServiceProvider Services { get; private set; } = null!;
    
    public override void Initialize()
    {
        DebugLogger.Log("==================================================");
        DebugLogger.Log("Application Initializing...");
        AvaloniaXamlLoader.Load(this);
    }

    public override void OnFrameworkInitializationCompleted()
    {
        DebugLogger.Log("Framework initialization starting.");
        Services = ConfigureServices();
        if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
        {
            DebugLogger.Log("Application lifetime is IClassicDesktopStyleApplicationLifetime.");
            desktop.MainWindow = new MainWindow
            {
                DataContext = Services.GetRequiredService<MainWindowViewModel>()
            };
            DebugLogger.Log("MainWindow created and DataContext set.");
        }

        base.OnFrameworkInitializationCompleted();
        DebugLogger.Log("Framework initialization completed.");
    }

    private static IServiceProvider ConfigureServices()
    {
        DebugLogger.Log("Configuring services.");
        var services = new ServiceCollection();

        // Register Services
        services.AddSingleton<IMessenger>(WeakReferenceMessenger.Default);
        services.AddSingleton<IIndexingService, IndexingService>();
        services.AddSingleton<ISearchService, SearchService>();
        services.AddSingleton<IFileParsingService, FileParsingService>();
        services.AddSingleton<IExportService, ExportService>();
        services.AddSingleton<IDialogService, DialogService>();
        // THIS IS THE REQUIRED LINE TO FIX THE CRASH
        services.AddSingleton<IEntryParserService, EntryParserService>();

        // Register Renderers
        services.AddSingleton<IMarkdownRenderer, MarkdownRenderer>();
        
        // Register ViewModels
        services.AddSingleton<GrimoireManagerViewModel>();
        services.AddTransient<TimelineViewModel>();
        services.AddTransient<AmandaMapViewModel>();
        services.AddTransient<ChatLogViewModel>();
        services.AddTransient<RitualBuilderViewModel>();
        services.AddTransient<TagMapViewModel>();
        services.AddTransient<YamlInterpreterViewModel>();
        services.AddTransient<MainWindowViewModel>();
        
        // Register Views (for the ViewLocator)
        services.AddTransient<MainWindow>();
        services.AddTransient<GrimoireManagerView>();
        services.AddTransient<TimelineView>();
        services.AddTransient<AmandaMapView>();
        services.AddTransient<TagMapView>();
        services.AddTransient<YamlInterpreterView>();
        services.AddTransient<ChatLogView>();
        services.AddTransient<RitualBuilderView>();

        return services.BuildServiceProvider();
    }
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\GPTExporterIndexerAvalonia.csproj ========================================
>> 
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>

  <ItemGroup>
    <!-- 
      Avalonia Packages: 
      Core framework dependencies for the user interface.
    -->
    <PackageReference Include="Avalonia" Version="11.0.10" />
    <PackageReference Include="Avalonia.Desktop" Version="11.0.10" />
    <PackageReference Include="Avalonia.Themes.Fluent" Version="11.0.10" />
    <PackageReference Include="Avalonia.Fonts.Inter" Version="11.0.10" />
    <PackageReference Include="Avalonia.ReactiveUI" Version="11.0.10" />

    <!-- 
      Community and Third-Party UI Packages:
      Additional controls and frameworks that enhance the UI.
    -->
    <PackageReference Include="Avalonia.HtmlRenderer" Version="11.0.0" />
    <!-- FIXED: Replaced the old, non-existent 'Avalonia.WebView' and 'Avalonia.WebView.Desktop' 
         packages with the single, correct 'WebView.Avalonia' package. -->
    <PackageReference Include="WebView.Avalonia" Version="11.0.0" />
    <PackageReference Include="CommunityToolkit.Mvvm" Version="8.2.2" />

    <!-- 
      Backend and Document Handling Packages:
      Libraries for file parsing, data handling, and other backend logic.
    -->
    <PackageReference Include="DocumentFormat.OpenXml" Version="3.0.2" />
    <PackageReference Include="VersOne.Epub" Version="3.3.4" />
    <PackageReference Include="Docnet.Core" Version="2.6.0" />
    <PackageReference Include="WebView.Avalonia.Desktop" Version="11.0.0" />
    <PackageReference Include="YamlDotNet" Version="15.1.2" />
    
    <!-- 
      Application Services:
      Support for modern application architecture patterns like Dependency Injection.
    -->
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="8.0.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\CodexEngine\CodexEngine.csproj" />
  </ItemGroup>
</Project>

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\Program.cs ========================================
>> 
// FILE: GPTExporterIndexerAvalonia/Program.cs
// REFACTORED
using Avalonia;
using Avalonia.ReactiveUI;
using System;
using Avalonia.WebView.Desktop;

namespace GPTExporterIndexerAvalonia;

internal class Program
{
    // Initialization code. Don't use any Avalonia, third-party APIs or any
    // SynchronizationContext-reliant code before AppMain is called: things aren't initialized
    // yet and stuff might break.
    [STAThread]
    public static void Main(string[] args) => BuildAvaloniaApp()
        .StartWithClassicDesktopLifetime(args);

    // Avalonia configuration, don't remove; also used by visual designer.
    public static AppBuilder BuildAvaloniaApp()
        => AppBuilder.Configure<App>()
            .UsePlatformDetect()
            .LogToTrace()
            .UseReactiveUI()
            .UseDesktopWebView();
}

>> ======================================== FILE: D:\github\phoenixcodex\GPTExporterIndexerAvalonia\ViewLocator.cs ========================================
>> 
using System;
using Avalonia.Controls;
using Avalonia.Controls.Templates;
using CommunityToolkit.Mvvm.ComponentModel;
using Microsoft.Extensions.DependencyInjection;

namespace GPTExporterIndexerAvalonia;

/// <summary>
/// This class is responsible for finding the correct View that corresponds to a given ViewModel.
/// It is a key part of the MVVM pattern in Avalonia.
/// </summary>
public class ViewLocator : IDataTemplate
{
    public bool Match(object? data)
    {
        return data is ObservableObject;
    }

    public Control? Build(object? data)
    {
        if (data is null)
        {
            return null;
        }

        // Correctly map the ViewModel type to its corresponding View type.
        // e.g., MainWindowTabViewModel -> MainWindowTabView
        var name = data.GetType().FullName!.Replace("ViewModel", "View");
        var type = Type.GetType(name);

        if (type != null)
        {
            // Ask the Dependency Injection container to create an instance of the View.
            var control = (Control)App.Current.Services.GetRequiredService(type);
            // The DataContext is already set by the TabControl's ItemsSource binding.
            return control;
        }

        return new TextBlock { Text = "View Not Found: " + name };
    }
}
